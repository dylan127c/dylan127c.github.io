[{"content":"概述 本文用于说明 OpenSSH 中的 ~/.ssh/config 配置文件的构成及注意事项。\n配置文件的意义 SSH 配置存在的意义，是可以自定义 SSH 客户端的行为，以满足特定需求。SSH 配置文件是一个文本文件，它通常的存储路径为：\n~/.ssh/config 该文件包含了 SSH 客户端的各种配置选项，可以用来配置 SSH 客户端的行为，例如：\n定义主机别名：你可以使用 Host 块为不同的主机定义别名，这样在连接远程主机时只需要使用别名即可，大大提高了操作的便捷性。 配置身份验证方式：你可以使用 IdentityFile 选项指定 SSH 客户端使用哪个身份验证文件进行身份验证，这样就不需要每次手动指定身份验证文件。 配置 SSH 连接选项：你可以使用各种选项来配置 SSH 连接的行为，例如连接超时时间、重试次数、使用的加密算法等等。 配置 SSH 代理：你可以使用 ProxyCommand 选项配置 SSH 代理，以便在使用 SSH 连接到无法直接访问的主机时使用。 配置 SSH 转发：你可以使用各种选项来配置 SSH 转发，例如本地端口转发、远程端口转发等等。 通过灵活使用 SSH 配置文件，你可以自定义 SSH 客户端的行为，使其更符合你的特定需求。此外，如果你需要经常连接到多个远程主机，使用 SSH 配置文件还可以节省你的时间和精力，提高你的工作效率。\n完整的配置示例 一个完整的 SSH 配置文件可能会包含许多参数，其中大部分都是可选的。以下是一个包含所有可用参数的 SSH 配置文件示例：\n# Global options\rHost *\rForwardAgent yes\rForwardX11 yes\rCompression yes\rServerAliveInterval 60\rServerAliveCountMax 3\r# Host-specific options\rHost example.com\rHostName example.com\rUser username\rPort 22\rIdentityFile ~/.ssh/my_private_key\rIdentitiesOnly yes\rPreferredAuthentications publickey,password\rProtocol 2\rCiphers aes128-ctr,aes192-ctr,aes256-ctr\rMACs hmac-sha2-256,hmac-sha2-512\rBatchMode yes\rConnectTimeout 10\rTCPKeepAlive yes\rLogLevel DEBUG\rUserKnownHostsFile ~/.ssh/known_hosts\rStrictHostKeyChecking ask\rVisualHostKey yes\rControlMaster auto\rControlPath ~/.ssh/master-%r@%h:%p\rControlPersist 600\r# Host-specific options for a wildcard pattern\rHost *.example.com\rProxyCommand ssh -q gateway.example.com nc -q0 %h %p 这个实例中包含了三个部分。\n第一部分定义了一些全局选项，包括打开代理转发、X11 转发、压缩和保持 SSH 连接的时间。 第二部分定义了一个名为 example.com 的主机，指定了用户名、端口、身份验证密钥等选项。我们还定义了一些其他选项，如身份验证首选项、协议版本、加密算法、日志级别等。 第三部分定义了一个使用通配符 *.example.com 的主机，为它指定了一个代理命令，以便通过网关主机连接到目标主机。 请注意，实际使用时，你不需要在 SSH 配置文件中指定所有可用选项，而是根据需要选择性地指定需要的选项。\n注意事项 本节主要说明配置文件中的一些细节问题。\n缩进不必要 在 SSH 配置文件中，使用缩进可以让文件更易于阅读和理解。但是，缩进不是必需的，你可以选择不使用缩进来编写 SSH 配置文件。\n然而，如果你不使用缩进，则需要确保每个选项都位于独立的一行上，且选项名和选项值之间需要用空格隔开。以下是一个不使用缩进的 SSH 配置文件示例：\nHost example.com\rHostName example.com\rUser username\rPort 22\rIdentityFile ~/.ssh/my_private_key\rIdentitiesOnly yes\rPreferredAuthentications publickey,password\rProtocol 2\rCiphers aes128-ctr,aes192-ctr,aes256-ctr\rMACs hmac-sha2-256,hmac-sha2-512\rBatchMode yes\rConnectTimeout 10\rTCPKeepAlive yes\rLogLevel DEBUG\rUserKnownHostsFile ~/.ssh/known_hosts\rStrictHostKeyChecking ask\rVisualHostKey yes\rControlMaster auto\rControlPath ~/.ssh/master-%r@%h:%p\rControlPersist 600 在这个示例中，每个选项都位于独立的一行上，且选项名和选项值之间使用空格隔开。\n请注意，即使不使用缩进，每个 Host 块的开头行也需要以“Host”开头，并且主机名称需要紧跟在后面。简而言之，配置之间是以“Host”作为分界的，每个配置都被称为 Host 块。\n虽然可以不使用缩进来编写 SSH 配置文件，但还是建议使用缩进来提高文件的可读性和可维护性。\nHost 块（别名） 使用 SSH 配置文件可以简化连接远程主机的操作，通过在 SSH 配置文件中定义 Host 块，你可以为不同的主机配置不同的选项，例如 HostName、User、IdentityFile 等等。\n这样，当你要连接到某个主机时，只需要使用该主机在 SSH 配置文件中定义的别名，而不需要再次输入主机名、用户名、身份验证文件等信息。\n例如，你在 SSH 配置文件中定义了以下 Host 块：\nHost myserver\rHostName example.com\rUser John\rIdentityFile ~/.ssh/my_private_key 那么，当你想要连接到 example.com 主机时，只需要使用以下命令即可：\nssh myserver SSH 将会自动使用 HostName 为 example.com，User 为 John，IdentityFile 为 ~/.ssh/my_private_key 的配置。\n这样，你就可以在连接到多个远程主机时，大大简化操作流程，提高工作效率。\n但需要注意，无论 ssh 命令中提供什么样的命令，SSH 都会默认会先匹配 Host，之后再根据命令中是否提供了 User 来进一步确定连接地址。\n例如，存以下的配置文件：\nHost github.com\rHostName %h\rUser John\rIdentityFile ~/.ssh/my_private_key 假设 GitHub 能够被正常访问，命令行发起以下连接请求：\nssh -T git@github.com SSH 会先把主机名 github.com 取出来匹配 Host 别名，因为任何情况下它首先可能是一个别名。\n如果存在 Host 为 github.com 的 Host 块时，SSH 会根据发起的请求是否具有 User 信息，来进一步确定是否使用配置中的默认 User 信息。\n由于以上的连接请求中使用了指定的 User（git），因此它将覆盖配置中默认的 User（John）作为连接的发起者。\n如果发起不带用户名的连接请求：\nssh -T github.com 它将直接匹配到 Host 别名中的配置，其等价于：\nssh -T John@github.com 现在修改一下配置文件：\nHost alias\rHostName github.com\rUser John\rIdentityFile ~/.ssh/my_private_key 由于别名的存在，如果希望访问到远程主机 github.com 则必须要在命令中使用别名：\nssh -T git@alias 诸如以下的 SSH 连接请求：\nssh -T github.com ssh -T git@github.com 均无法成功匹配到 Host 块，这些请求一般会以找寻不到私钥的存在，导致验证失败而告终：\nPermission denied (publickey). 之前说过，Host 一般用于分割配置，即如果存在多个配置，则 Host 必须提供。否则多个配置就会被视为同一个配置，这样是十分不合理的。\n如果只有一个配置呢？是否可以省略 Host 配置？答案是肯定的，但实际并不推荐这样做。\n假设存在以下配置：\nHostName github.com\rUser John\rIdentityFile ~/.ssh/my_private_key 该配置实际等价于：\nHost github.com\rHostName %h\rUser John\rIdentityFile ~/.ssh/my_private_key 即所有主机写作 github.com 的连接都会匹配这条规则。\n大小写无限制 在 SSH 配置文件中，大小写通常是不敏感的。这意味着你可以使用大写字母、小写字母或混合大小写字母来编写选项名和主机名，它们都会被正确地解析和识别。例如，下面的两个 Host 块是等价的：\nHost example.com\rHostName example.com\rUser username\rIdentityFile ~/.ssh/my_private_key\rhost example.com\rhostname example.com\ruser username\ridentityfile ~/.ssh/my_private_key 无论你是使用大写字母、小写字母或混合大小写字母编写选项名和主机名，SSH 都会将它们解释为相同的选项名和主机名。因此，在 SSH 配置文件中，大小写通常是没有限制的。\n","permalink":"https://dylan127c.github.io/posts/openssh-config/","summary":"概述 本文用于说明 OpenSSH 中的 ~/.ssh/config 配置文件的构成及注意事项。\n配置文件的意义 SSH 配置存在的意义，是可以自定义 SSH 客户端的行为，以满足特定需求。SSH 配置文件是一个文本文件，它通常的存储路径为：\n~/.ssh/config 该文件包含了 SSH 客户端的各种配置选项，可以用来配置 SSH 客户端的行为，例如：\n定义主机别名：你可以使用 Host 块为不同的主机定义别名，这样在连接远程主机时只需要使用别名即可，大大提高了操作的便捷性。 配置身份验证方式：你可以使用 IdentityFile 选项指定 SSH 客户端使用哪个身份验证文件进行身份验证，这样就不需要每次手动指定身份验证文件。 配置 SSH 连接选项：你可以使用各种选项来配置 SSH 连接的行为，例如连接超时时间、重试次数、使用的加密算法等等。 配置 SSH 代理：你可以使用 ProxyCommand 选项配置 SSH 代理，以便在使用 SSH 连接到无法直接访问的主机时使用。 配置 SSH 转发：你可以使用各种选项来配置 SSH 转发，例如本地端口转发、远程端口转发等等。 通过灵活使用 SSH 配置文件，你可以自定义 SSH 客户端的行为，使其更符合你的特定需求。此外，如果你需要经常连接到多个远程主机，使用 SSH 配置文件还可以节省你的时间和精力，提高你的工作效率。\n完整的配置示例 一个完整的 SSH 配置文件可能会包含许多参数，其中大部分都是可选的。以下是一个包含所有可用参数的 SSH 配置文件示例：\n# Global options\rHost *\rForwardAgent yes\rForwardX11 yes\rCompression yes\rServerAliveInterval 60\rServerAliveCountMax 3\r# Host-specific options\rHost example.","title":"OpenSSH Config"},{"content":"概述 工欲善其事，必先利其器。本篇用于记录个人开发环境及系统环境的配置。\n编程字体 编程字体推荐，包括英文字体和中文字体两类。请在非商用的情况下，使用它们。\n英文字体推荐：Cascadia Code、SF Pro Text、SF Pro Display、Consolas；\n中文字体推荐：PingFang SC、Microsoft YaHei。\n正如本页面所示，如果所有静态资源能够正常加载，那么所有中文都会使用 PingFang SC 字体显示。\n英文字体部分会根据内容的不同，而有所差别。其中正文采用了 SF Pro Text 字体，标题采用了 SF Pro Display 字体，代码块则采用了 Cascadia Code 字体。\n# 注释部分应用了 PingFang SC 字体和 Cascadia Code 字体\rname = dylan\rdiableAuto = true\rfontFamily = Cascadia Code, PingFang SC 注意到注释部分，如果觉得中英文字体之间不太和谐，那么可以通过 CSS 的类选择器来其应用其他的英文字体。\n针对 Cascadia Code 字体和 PingFang SC 字体有两点说明：\nCascadia Code 有几个不同的变体，具体区别可以参考 Cascadia Code 版本； PingFang SC 中 Medium 字重的显示效果比 Regular 要好，可以将 Medium 字重的 font-weight 设置为 400（标准）。 如果希望在 Windows 系统程序中使用它们，请获取它们的 .ttf 字体文件，并在右键菜单选择“为所有用户安装”：\n关于字体，想了解更多可以参考：Fonts。\n程序配置 以下是常用软件的一些常用配置信息。\nIntelliJ IDEA 中文语言包：\n主题 One Dark Theme：\n外观选项卡：\n字体选项卡：\n配色方案选项卡：\nVisual Studio Code VSCode 有账户同步配置的功能，推荐登录微软账号进行配置的同步。它提供的配置方式有两种，一种是软件层面上，另一种是代码层面上的。\n软件层面上的即设置选项卡：\n修改设置选项卡中的项目，会同步将变更写入到配置文件中。\n代码层面上的即直接操作设置文件：\n配置参考：\n{ \u0026#34;workbench.startupEditor\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;One Dark Pro Flat\u0026#34;, \u0026#34;editor.fontSize\u0026#34;: 16, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;Cascadia Code, PingFang SC, Microsoft YaHei, Consolas, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34;, \u0026#34;editor.unicodeHighlight.includeComments\u0026#34;: false, \u0026#34;http.proxy\u0026#34;: \u0026#34;socks5://127.0.0.1:13766\u0026#34;, \u0026#34;http.proxySupport\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.unicodeHighlight.allowedLocales\u0026#34;: { \u0026#34;zh-hant\u0026#34;: true } } VSCode 同样可以配置简中显示语言及 One Dark Pro 主题：\n其中 One Dark 主题同样拥有 4 种不同的配色方案，使用以下方式可快捷更改：\nTypora 偏好设置中，通用选项卡需要配置以下几个选项：\n通用 -\u0026gt; 启动选项：重新打开上次使用的文件和目录； 通用 -\u0026gt; 保存恢复：勾选自动保存； 通用 -\u0026gt; 高级设置：勾选开启调试模式。 图像选项卡需要配置以下几个选项：\n图像 -\u0026gt; 语法偏好：勾选优先使用相对路径； 图像 -\u0026gt; 插入图片：复制到指定路径并填入以下路径规则，同时勾选对本地位置的图片应用上述规则。 ./images/${filename}.images 其余的偏好设定可以维持默认。\n关于主题，所有的主题配置文件都位于以下目录：\n~\\AppData\\Roaming\\Typora\\themes 以 GitHub 主题为例，它的配置文件为 github.css。如果需要覆盖这些配置，仅需要在 themes 目录下创建 github.user.css 文件。\nTypora 会顺序读取 github.css、github.user.css 文件的内容，用户自定义的主题样式显然会覆盖掉原本的主题样式。\n如需获取其他 Typora 主题，请参考：Typora Themes。\n通过编辑注册表，可以将 Typora 支持的 .md 类型添加到“新建”菜单中：\n具体操作步骤如下：\n使用 Win + R 快捷键打开运行窗口，输入 regedit 并确认，以打开注册表窗口； 定位到注册表 HKEY_CLASSES_ROOT\\.md 路径下，修改 .md 项中默认字符串的数据值为 Typora.md; 在 .md 项下新建 ShellNew 项，并添加字符串值 NullFile，不需要设置数据值。 实际上 .md 格式仅能由指定的程序打开，就本机来说支持打开的这种格式的有 Typora、VSCode 等。\n默认能够打开 .md 格式文件的程序，会配置在注册表中 .md 项下的 OpenWithProgids 里：\n这也是为什么 .md 项中默认字符串的数据值能被设置为 Typora.md 的原因。除此之外你还能将它设置为 VSCode.md，即 .md 项中的默认字符串值只能接受 Typora.md 或 VSCode.md。\n如果在 .md 项中填入 VSCode.md，则新建菜单会变成：\n你会发现改变的只有新建 Markdown 文件项的名称，它仍然可以被新建，但打开它的程序仍旧是 Typora。\n这很好理解，因为本次修改注册表并未影响默认打开 .md 类型文件的软件预设，预设打开 .md 类型文件的仍旧是 Typora 程序，而非 VSCode 程序。\n希望修改默认打开程序，请在指定格式文件的属性中选择更改打开方式：\n并不推荐通过注册表的方式，为指定类型的文件选择固定的打开程序，因为注册表的设置比较复杂！且影响深远！非必要情况下尽量不要改动注册表，以免系统遭到不必要的损坏，能安全达到预期效果才是我们需要的最好结果。\nXshell 从护眼的角度出发，可以选择程序自带的 XTerm 配色方案。亦或将以下类 Ubuntu 的配色方案保存为 .xcs 文件，导入到配色方案中使用。\n[Ubuntu]\rtext(bold)=ffffff\rmagenta(bold)=ad7fa8\rtext=ffffff\rwhite(bold)=eeeeec\rgreen=4e9a06\rred(bold)=ef2929\rgreen(bold)=8ae234\rblack(bold)=555753\rred=cc0000\rblue=3465a4\rblack=000000\rblue(bold)=729fcf\ryellow(bold)=fce94f\rcyan(bold)=34e2e2\ryellow=c4a000\rmagenta=75507b\rbackground=300a24\rwhite=d3d7cf\rcyan=06989a\r[Names]\rcount=1\rname0=Ubuntu Maven Maven 仓库主要的问题是下载源，对于下载源为国外的 JAR 包，将它们下载至本地可能需要花上不少的时间，如果遇上无法下载的情况，就更是让人头大。\n最好的方式，是将 Maven 仓库默认的源修改为国内的镜像源。\nIntelliJ IDEA 将默认的 Maven 配置放在了固定的地方，无论用户更换什么版本的 Maven 程序，该配置通用且默认生效（本地仓库路径亦是如此）：\n定位至 /.m2 目录，将 settings.xml 修改为以下内容：\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;/settings\u0026gt; 如果 settings.xml 配置不存在，请自行创建它。更多镜像源配置，请参考阿里云云效 Maven。\n除了阿里云之外，还可选择使用其他的 Maven 源，网络上很容易就能检索到其他的 Maven 源。\nListary Listary 是一款用于 Windows 的文件搜索、定位的辅助软件。它提供了便捷、人性化的文件（夹）定位方式，改善 Windows 传统低效的文件打开/保存对话框，同时改善了常见文件管理器中文件夹切换的效率。\nListary 一般用于文件检索，但它还能用来进行网络搜索。常用的网络搜索配置如下：\n根据英文翻译中文的 url 配置为：\nhttps://translate.google.com/#view=home\u0026amp;op=translate\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;text={query} 根据中文翻译英文的 url 配置为：\nhttps://translate.google.com/#view=home\u0026amp;op=translate\u0026amp;sl=zh-CN\u0026amp;tl=en\u0026amp;text={query} 双击 Ctrl 唤醒 Listary 输入“fy ”即可唤醒英中翻译：\n键入单词按回车键，Listary 就会调用浏览器打开指定 url 进行单词检索：\n如果希望找寻某一路径下的指定文件，可以在检索文件的时候添加上指定路径。\n例如，系统中存在多个 config 文件，目标检索的 config 文件位于 .ssh 目录，那么检索规则为：\n这里需要注意 Windows 系统下，文件路径中使用的是反斜杠“\\”，如果错误输入了斜杠“/”，则无法检索到结果。\n获取 Listary 请参考：Listary 6.1。\nParsec Parsec 是依赖代理服务的远程控制软件，可以说大多数情况下必须提供代理，以登录 Parsec 账户以使用其功能。\nParsec 安装过程中会让用户选择软件的使用对象，它将根据该结果来选择存放应用程序数据的目录：\nShared（为所有用户安装）：Parsec 的配置文件 config.txt 位于 C:\\ProgramData\\Parsec\\ 目录下； Per User（仅为当前用户安装）：Parsec 的配置文件 config.txt 位于 C:\\user\\username\\AppData\\Roaming 目录下。 只需要保证 config.txt 配置中有以下内容：\n# 代理服务器配置\rapp_proxy_address = x.x.x.x\rapp_proxy_scheme = http\rapp_proxy = true\rapp_proxy_port = xxx\r# 开启虚拟显示器和隐私模式\rhost_virtual_monitors = 1\rhost_privacy_mode = 1 希望多了解 Parsec 的工作原理，请参考：parsec-远程控制。\nClash for Windows 基本配置：\nTUN Mode 配置：\n推荐启用 Rule 模式：\n订阅文件可以使用 JavaScript 进行改写，详情请参考官方文档：Clash for Windows - 配置文件预处理。\n获取 Clash for Windows 请参考：clash for windows pkg - releases。\n个人规则、分组的实现，请参考：Proxy Rules。\nMacType MacType 是一个替代 Windows 自身核心部件 GDI 进行字体渲染的开源软件。该软件由中国网友 FlyingSnow 基于已经停止更新的 gdi++ 开发，使用可配置性较高的 FreeType 渲染字体。\n软件安装后，推荐以注册表方式启动：\nWindows Registry Editor Version 5.00\r[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows]\r\u0026#34;AppInit_DLLs\u0026#34;=\u0026#34;MacType64.dll\u0026#34;\r\u0026#34;LoadAppInit_DLLs\u0026#34;=dword:00000001\r\u0026#34;RequireSignedAppInit_DLLs\u0026#34;=dword:00000000\r[HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows]\r\u0026#34;AppInit_DLLs\u0026#34;=\u0026#34;MacType.dll\u0026#34;\r\u0026#34;LoadAppInit_DLLs\u0026#34;=dword:00000001\r\u0026#34;RequireSignedAppInit_DLLs\u0026#34;=dword:00000000 系统为 Windows x64 时，将以上内容保存为 .reg 文件并运行即可。如果是 x86 系统，则仅保存并运行上半部分内容。\n以注册表启动 MacType 能获取最无缝的渲染体验，但启用该方式需要满足两点前置条件：\n将 MacType 安装路径添加到环境变量 Path 中； 关闭 BIOS 中的 Secure Boot 安全启动项； 详情参考：Enable Registry Mode Manually。\n使用 MacType 无需安装额外的字体，推荐选择 Clean Light 渲染主题：\n获取 MacType 请参考：MacType。\n","permalink":"https://dylan127c.github.io/posts/workspace-config/","summary":"概述 工欲善其事，必先利其器。本篇用于记录个人开发环境及系统环境的配置。\n编程字体 编程字体推荐，包括英文字体和中文字体两类。请在非商用的情况下，使用它们。\n英文字体推荐：Cascadia Code、SF Pro Text、SF Pro Display、Consolas；\n中文字体推荐：PingFang SC、Microsoft YaHei。\n正如本页面所示，如果所有静态资源能够正常加载，那么所有中文都会使用 PingFang SC 字体显示。\n英文字体部分会根据内容的不同，而有所差别。其中正文采用了 SF Pro Text 字体，标题采用了 SF Pro Display 字体，代码块则采用了 Cascadia Code 字体。\n# 注释部分应用了 PingFang SC 字体和 Cascadia Code 字体\rname = dylan\rdiableAuto = true\rfontFamily = Cascadia Code, PingFang SC 注意到注释部分，如果觉得中英文字体之间不太和谐，那么可以通过 CSS 的类选择器来其应用其他的英文字体。\n针对 Cascadia Code 字体和 PingFang SC 字体有两点说明：\nCascadia Code 有几个不同的变体，具体区别可以参考 Cascadia Code 版本； PingFang SC 中 Medium 字重的显示效果比 Regular 要好，可以将 Medium 字重的 font-weight 设置为 400（标准）。 如果希望在 Windows 系统程序中使用它们，请获取它们的 .","title":"Workspace Config"},{"content":"安卓子系统 Windows Subsystem for Android（WSA）是微软在 Windows 11 系统上推出的 Android 子系统，它允许将 Android 应用部署在 Windows 系统上。\nWSA 可以通过 Microsoft Store 获取并安装，但目前国区的应用商店内并没有上架。\n虚拟化技术 Windows Subsystem for Android 依赖于虚拟化技术，需要在 Windows 功能中启用 Hyper-V 功能和虚拟机平台功能，请参考：虚拟化技术。\nWSA 安装 虽然国区的应用商店内没有上架 WSA 安卓子系统应用，但仍旧可以使用某些手段，将 WSA 安装到 Windows 系统上。\n第一种方式需要修改系统设置内的国家或地区选项，将“中国”修改为“美国”（或其它支持安装 WSA 安卓子系统应用的区域）：\n修改完毕后打开 Microsoft Store 应用商店，它将自动定位到美区的应用市场上。\n搜索 Amazon Appstore 下载并安装，WSA 也将会一并安装到 Windows 系统中：\n这种方式虽然很简单，但没人知道微软是否会在未来对应用商店的区域进行封锁。如果未来微软对商店区域进行封锁，还可以选择使用第二种安装方式。\n第二种方式需要借助命令行安装，它没有第一种方式那么简单，且安装前需要自行获取 WSA 的离线安装包。\n访问 Microsoft Store - Generation Project 搜索 WSA 的 ProductId 产品编码 9P3395VX91NR：\n列表最末尾的 .msixbundle 类型文件就是 WSA 安装包文件，直接下载到本地即可。\n进入安装包所在目录，以管理员身份打开 Windows PowerShell 终端并执行命令：\nAdd-AppxPackage .\\MicrosoftCorporationII.WindowsSubsystemForAndroid_2206.40000.15.0_neutral___8wekyb3d8bbwe.Msixbundle 命令执行完毕后 WSA 的安装也完成了。Windows 11 系统下，可以在全部应用中查看到 WSA 安卓子系统应用：\nAndroid 应用安装 WSA 部署完毕后，会同时将亚马逊应用商店（Amazon Appstore）安装到安卓子系统中，以便于使用者安装其他的 Android 应用。但受国区限制，亚马逊应用商店一般无法使用。\n因此，在 WSA 中安装 Android 应用需借助其他手段，即 Android 调试桥（Android Debug Bridge, adb）。该工具可以使用命令行的方式，直接将 Android 应用安装至 WSA 中。\n使用 ADB 工具可以通过任何第三方应用商店将应用安装至 WSA 中，但这也意味着 Android Package（.apk）需要自行获取。\nAndroid 调试桥 ADB 工具在 Windows 系统下，是一个简单的 abd.exe 可执行程序，但它仅能够在终端中以命令行的形式调用。\nADB 工具可从 Platform Tools 网站获取，选择“适用于 Windows 的 SDK Platform-Tools”下载：\n下载解压后，为了配置全局环境变量方便直接调用，推荐将该目录放置到固定的位置：\n将 abd.exe 所在目录添加到系统变量下的 Path 中：\n启用开发者模式 ADB 工具本质用于调试 Android 系统，启用调试需要连接到指定的 Android 系统。而 Android 系统如果要接受调试，则必须启用开发人员模式（开发者模式）。\n打开 WSA 子系统，在开发人员选项卡中启用开发人员模式：\n首次启用开发人员模式时，WSA 内的调试模式可能仍尚未启用，使用 ADB 工具连接 WSA 可能会提示连接失败。\n解决方法是重启子系统，或进入管理开发人员设置手动激活开发人员模式。\n连接/断开 Android 系统 以下命令用于连接 Android 系统：\nadb connect 127.0.0.1:58526 以下命令用于断开 Android 系统：\nadb disconnect 127.0.0.1:58526 使用 ADB 安装应用 ADB 工具安装应用的命令十分简短，连接 WSA 后使用以下命令即可安装任意 Android 应用：\nadb install {android package path} 以 Apple Music 为例，你需要获取 Apple Music.apk 安装包，并执行安装 Android 应用的命令：\n待命令输出完毕后，表示应用安装完成。Windows 11 系统下，你可以在全部应用中找到已安装的 Android 应用入口：\n卸载应用与卸载 UWP 应用无异，只需要在应用图标上右键菜单中选择卸载，即可移除指定的 WSA 应用。\n更多设置 WSA 默认采用的子系统资源策略是连续模式，该模式下子系统始终运行在后台，以便加快 WSA 应用的启动速度。\n简单来说，子系统资源中如果选择了连续模式，就等同于选择了让 WSA 随开机一起自启动。\n如果需要频繁使用 WSA 应用，则推荐选择连续模式，否则可以选择按需要模式。\n其他问题 WSA 安装子系统在使用的过程中，经常弹出以下连接受限通知：\n但实际上 VirtWifi 并非受限，换句话说 WSA 内的网络访问实际没有问题。\n可以使用 ABD 调试工具，以命令行的方式关闭 WSA 的连接受限通知：\nadb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 adb shell settings put global captive_portal_http_url http://www.google.cn/generate_204 从命令行中不难知道，WSA 内使用 https://www.google.cn/generate_204 网址作为 VirtWifi 是否受限的测试链接，但该网址在国内始终是处于不可访问的状态。这样即便 VirtWifi 网络正常，WSA 内的网络连通性测试大概率也会以失败告终，反馈到 Windows 系统通知中就是连接受限了。\n","permalink":"https://dylan127c.github.io/posts/windows-subsystem/","summary":"安卓子系统 Windows Subsystem for Android（WSA）是微软在 Windows 11 系统上推出的 Android 子系统，它允许将 Android 应用部署在 Windows 系统上。\nWSA 可以通过 Microsoft Store 获取并安装，但目前国区的应用商店内并没有上架。\n虚拟化技术 Windows Subsystem for Android 依赖于虚拟化技术，需要在 Windows 功能中启用 Hyper-V 功能和虚拟机平台功能，请参考：虚拟化技术。\nWSA 安装 虽然国区的应用商店内没有上架 WSA 安卓子系统应用，但仍旧可以使用某些手段，将 WSA 安装到 Windows 系统上。\n第一种方式需要修改系统设置内的国家或地区选项，将“中国”修改为“美国”（或其它支持安装 WSA 安卓子系统应用的区域）：\n修改完毕后打开 Microsoft Store 应用商店，它将自动定位到美区的应用市场上。\n搜索 Amazon Appstore 下载并安装，WSA 也将会一并安装到 Windows 系统中：\n这种方式虽然很简单，但没人知道微软是否会在未来对应用商店的区域进行封锁。如果未来微软对商店区域进行封锁，还可以选择使用第二种安装方式。\n第二种方式需要借助命令行安装，它没有第一种方式那么简单，且安装前需要自行获取 WSA 的离线安装包。\n访问 Microsoft Store - Generation Project 搜索 WSA 的 ProductId 产品编码 9P3395VX91NR：\n列表最末尾的 .msixbundle 类型文件就是 WSA 安装包文件，直接下载到本地即可。","title":"Windows Subsystem"},{"content":"虚拟机 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。\n在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。\nVMware Workstation VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。\nVMware Workstation 可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT 开发人员和系统管理员而言， VMware 在虚拟网路，实时快照，拖曳共享文件夹，支持 PXE 等方面的特点使它成为必不可少的工具。\nHyper-V Hyper-V 是微软的一款虚拟化产品，是微软第一个采用类似 Vmware ESXi 和 Citrix Xen 的基于 hypervisor 的技术。这也意味着微软会更加直接地与市场先行者 VMware 展开竞争，但竞争的方式会有所不同。\nHyper-V 是微软提出的一种系统管理程序虚拟化技术，能够实现桌面虚拟化。Hyper-V 最初预定在 2008 年第一季度，与 Windows Server 2008 同时发布。Hyper-V Server 2012 完成 RTM 版发布。\n虚拟化技术 一般的个人计算机都支持虚拟化技术，使用该技术需要先在 BIOS 主板中开启特定功能：\n支持 Intel 芯片组的主板，需要在 BIOS 中启用 Intel Virtualization Technology (VT-x）选项； 支持 AMD 芯片组的主板，需要在 BIOS 中启用 SVM Mode 选项。 对于 VMware Workstation 来说，只要 BIOS 中启用了 VT-x 或 SVM Mode 后，无需额外的设置，安装后即可可使用。\n对于 Hyper-V 来说，则还需要在 Windows 功能选项卡中启用 Hyper-V 及虚拟机平台等两项功能：\n此外，还需要以管理员身份打开终端，将管理程序启动类型设置为 AUTO：\nbcdedit /set hypervisorlaunchtype auto 兼容性问题 VMware 和 Hyper-V 在技术层面上互不兼容，如果 Windows 功能中启用了 Hyper-V 功能，则会导致 VMware 虚拟机启动失败。\n如果你希望在系统上继续使用 VMware，需要关闭 Hyper-V 功能，同时将管理程序启动类型设置为 OFF：\nbcdedit /set hypervisorlaunchtype off 虚拟机显卡直通 虚拟机显卡直通（Virtual Machine GPU Passthrough）是一种将物理GPU（显卡）分配给虚拟机的技术，使得虚拟机可以直接访问物理显卡，获得近乎原生的显卡性能。\n传统的虚拟机在运行时通常是使用宿主机的 CPU 和内存资源进行模拟运算，但在需要高性能显卡加速的场景下，由于虚拟机无法直接访问物理显卡，因此无法发挥显卡加速的优势。\n虚拟机显卡直通技术则可以将物理显卡分配给虚拟机，使虚拟机可以直接访问物理显卡，从而获得接近原生的显卡性能，适用于需要进行 GPU 密集型计算、图形渲染、视频处理等场景。\nParsec 远程控制 Parsec 是一款基于云游戏技术的远程桌面软件，可以让用户通过互联网访问远程计算机上的桌面环境，并在本地实现低延迟、高清晰度的游戏、应用等体验。\n使用 Parsec，用户可以将自己的游戏、应用程序等运行在远程计算机上，然后通过网络将计算机上的图像和声音传输到本地计算机上，实现类似于本地运行的效果。此外，Parsec 还支持云游戏平台，用户可以租用云上的计算资源，在云端运行游戏和应用程序，并通过网络将图像和声音传输到本地计算机上，实现游戏的流畅运行。\nParsec 采用了一系列优化技术，包括网络协议优化、视频编解码优化、音频编解码优化等，使得用户在使用 Parsec 时可以获得低延迟、高清晰度的远程体验。同时，Parsec 还支持多平台，包括 Windows、Mac、Linux、Android 等操作系统。\n传输原理 Parsec 的传输原理基于视频流和音频流的实时传输。在运行 Parsec 的远程计算机上，会截取计算机的屏幕和音频数据，并对其进行压缩和编码，然后将其转化为视频流和音频流，并通过网络发送到本地计算机。\n在本地计算机上，Parsec 会解码视频流和音频流，并在本地计算机上进行渲染和播放，最终呈现给用户的是在本地计算机上的实时画面和声音。\n为了保证传输质量和延迟，Parsec 使用了一系列优化技术，包括网络协议优化、视频编解码优化、音频编解码优化等。例如，Parsec 使用了自己的网络协议，支持 UDP 协议和 FEC（Forward Error Correction）纠错技术，可以最大程度地降低网络延迟和丢包率。\n同时，Parsec 还采用了 H.265 视频编解码和 Opus 音频编解码等高效的编解码算法，可以在保证传输质量的情况下，尽可能地减小视频和音频流的带宽占用。\n简单地说，Parsec 的远程控制更像是“远程播放”，这种借助物理 GPU 对桌面内容和音频进行编解码的远程访问效率十分地高。远程计算机的 GPU 性能如果足够强大，那么影响远程控制延迟的唯一因素就仅剩网络传输速率了。\n使用条件 据使用体验，使用 Parsec 实际需具备两个条件：1. 远程计算机的 GPU 性能需足够强大；2. 远程和本地计算机需要具备代理服务器。\n基于它的传输原理，不难得知远程计算机的 GPU 需具备一定的性能，才能应付大量的编解码操作，这实际是使用 Parsec 的其中一个弊端。\n另一个弊端是 Parsec 为国外推出的远程控制软件，它天生与国内网络相性不好。最简单的一点，使用 Parsec 必须登录个人账户，如果没有代理，软件可能无法使用，甚至于申请注册 Parsec 账号都会成为阻碍。\n但实际代理网络只用在申请注册 Parsec 账户或登录 Parsec 账户时，Parsec 本身建立远程连接并不依赖于代理网络。\nEasy-GPU-PV Easy-GPU-PV 是 GitHub 上的一个开源项目，它是由远程控制软件 Parsec 的作者所编写的、用于一键部署能支持 GPU 直通的 Hyper-V 虚拟机的脚本。\n该项目建立在 Hyper-V 虚拟机能支持 GPU 直通的基础上，配合 Parsec 远程连接，让用户可以在不影响真实物理机的情况下，实现远程控制高性能虚拟机的目的。\nHyper-V 本身就支持 GPU 直通，但部署过程十分繁琐，涉及诸多的 Shell 命令，因此建议直接使用项目中提供的一键部署脚本。\n使用一键部署脚本前，只需要修改部分参数即可，脚本运行后的数分钟内，支持 GUP 直通的 Hyper-V 虚拟机就能部署完成。\n项目中仅有三个主要的脚本文件需要了解：\nPreChecks.ps1：用于在一键部署之前执行的必要系统检查； CopyFilesToVM.ps1：将自动把显卡直通的虚拟机部署到 Hyper-V 管理器中 ； Update-VMGpuPartitionDriver.ps1：用于更新显卡驱动，物理机显卡驱动如果进行了更新，则需要执行该脚本同步更新虚拟机内的显卡驱动。 执行 Easy-GPU-PV 部署脚本之前，请参考虚拟化技术启用 Hyper-V 虚拟机。\n系统检查 进入 Easy-GPU-PV 目录内，以管理员身份运行 Windows PowerShell 并执行以下检查命令：\n.\\PreChecks.ps1 如果执行过程中出现错误，一般表明需要调整 Windows PowerShell 的执行策略，修改 Execution Policy 为不受约束的（unrestricted）：\nSet-ExecutionPolicy unrestricted 执行调整后，再次运行 PreChecks.ps1 脚本检查系统是否符合部署要求：\n如果没有报错，就可以进行下一步了。\n虚拟机部署 部署需要使用 CopyFilesToVM.ps1 脚本，在部署前建议调整脚本内参数。\n使用文本编辑器将 CopyFilesToVM.ps1 脚本打开，内容大致如下：\n红框所示的是可自定义的基础参数，其中推荐进行自定义的参数有以下几个：\nVMName：虚拟机名称，推荐进行自定义方便管理； SourcePath：虚拟机系统镜像，镜像需要自行下载，并将镜像所在的路径配置到此参数中； Edition：系统镜像的版本，需要通过指定的命令获取； SizeBytes：动态磁盘的大小； MemoryAmount：虚拟机内存大小，该项为固定内存容量，不是动态内存； CPUCores：虚拟机 CPU 核心数据，需要根据物理机的总线程数量来作出配置； VHDPath：虚拟机动态磁盘的存储路径； GPUName：显卡名称，Windows 10 系统只能使用 AUTO 值，Windows 11 系统则可以自定义值； GPUResourceAllocationPercentage：显卡资源分配比例，动态参数，即虚拟机占用显卡资源的最大百分比值； Username：用户名称； Password：登录密码； Autologon：是否启用自动登录。 部署过程中需要使用到系统镜像，请到 Windows 11 磁盘映像（ISO）或其他网站下载。\n系统版本 Edition 参数，需装载 ISO 镜像以命令行的方式获取。例如 Windows 10 专业版的系统镜像，想要获取该镜像的 Edition 版本参数，需先将镜像装载到物理机中：\n随后进入装载好的 DVD 驱动器目录内，以管理员身份打开 Windows PowerShell 终端并执行以下命令：\ndism /Get-WimInfo /WimFile:K:\\sources\\install.wim 终端会输出详细版本的索引信息，对应系统镜像的索引就是 CopyFilesToVM.ps1 文件中的 Edition 参数值：\n这里 Windows 10 专业版所需要配置 Edition 参数的值，即为其索引值 3。\n基本配置完成后，即可开始执行 CopyFilesToVM.ps1 脚本部署 Hyper-V 虚拟机：\n.\\CopyFilesToVM.ps1 只要参数不出错，那么整个部署脚本的执行过程将十分顺利。\n脚本执行完毕后按任意键退出终端即可，虚拟机将自动打开：\n驱动更新 GPU 直通的本质是 Hyper-V 支持将物理机的资源分配给虚拟机，但虚拟机使用 GPU 资源的前提是系统内拥有 GPU 的驱动程序，且该驱动程序的版本必须与物理机上的 GPU 驱动版本保持一致。\n因此，如果物理机上的显卡驱动进行了更新，那么虚拟机内的显卡驱动也需要进行更新。\n显卡驱动更新同样需要进入脚本目录，在 Windows PowerShell 中执行以下命令即可：\nUpdate-VMGPUPartitonDriver.ps1 -VMName \u0026#34;Name of your VM\u0026#34; -GPUName \u0026#34;Name of your GPU\u0026#34; 关于 GPU 完整的名称，可以在系统的设备管理器中查看。\n自动部署遗留问题 脚本部署虚拟机的整个过程可以说是行云流水的，但实际还存在某些问题，或者说是预设软件的安装存在某些问题。\n驱动缺失 虚拟机部署完毕后，设备管理器中必须拥有以下两个设备的信息：\n声音、视频和游戏控制器：VB-Audio Virtual Cable 显示适配器：Parsec Virtual Display Adapter 以上红框内的设备是必须存在的。其中，通用即插即用监视器就是 Parsec 内置的虚拟显示器，该显示器仅在客户机建立连接时被启用。\n但大多数情况下，脚本运行完毕且虚拟机配置结束后，设备管理器中就只会存在 VB-Audio Virtual Cable 这一个设备的信息。这种情况的出现，是因为系统缺少了必要的 Parsec Virtual Display Driver 驱动，而该驱动并未能通过部署脚本成功安装到系统中。\nEasy-GPU-PV 项目的作者在说明文档中阐述了该问题：如果虚拟机部署、启动速度太快，很可能会导致某些驱动出现未成功安装的情况。\n查看 Windows 系统的计划任务程序，可以看到其中预设的两项任务详情：\n其中 Install Parsec Display Driver 任务用于安装 Parsec Virtual Display Adapter 驱动。\n如果是根据项目作者所说的，部署、启动速度过快导致驱动无法安装成功的情况，一般在多次重启虚拟机后，驱动能够得到修复，但能够修复是小概率事件。如果情况没能得到修复，则推荐将以上两项计划任务删除并自行完成修复。\n修复的方法很简单：卸载 Parsec 并重新安装，安装过程中务必勾选 Virtual Display Driver 选项。\n注意事项：\n推荐使用 Uninstall Tools 卸载 Parsec，以避免不必要的错误。\n安装完毕后，推荐将 parsecd.exe 程序设置为“以管理员身份运行此程序”，以避免不必要的错误。\n网络故障 虚拟机部署完毕后，有一种情况会导致 Parsec 无法安装，即网络出现不明原因的故障。Parsec 无法安装，自然必要驱动也不存在。\n原因是 Parsec 并不是国内的软件，计划任务需要从网络中获取 Parsec 程序的安装包。这个过程中如果网络连接不上（故障），则会导致 Parsec 程序的安装包无法获取的情况，自然程序也无法安装。\n如果出现这种网络故障，一般表明自行获取安装包的途径也是不可取的。推荐使用代理服务器，让代理软件将系统流量进行代理转发，Parsec 程序的安装包就可以顺利完成下载了。\nParsec 软件配置 Parsec 本身是一款在国内未拥有代理商的软件，使用它必需拥有 Parsec 的账户用于登录。因此，使用代理进行账号的注册与登录几乎是必须的。\nParsec 安装过程中会让用户选择软件的使用对象，它将根据该结果来选择存放应用程序数据的目录：\nShared（为所有用户安装）：Parsec 的配置文件 config.txt 位于 C:\\ProgramData\\Parsec\\ 目录下； Per User（仅为当前用户安装）：Parsec 的配置文件 config.txt 位于 C:\\user\\username\\AppData\\Roaming 目录下。 Parsec 支持配置代理服务器，只需要在 Parsec 配置文件添加代理服务器的信息即可：\napp_proxy_address = x.x.x.x\rapp_proxy_scheme = http\rapp_proxy = true\rapp_proxy_port = xxx 如果因为驱动缺失或网络故障等原因，需要自行安装 Parsec 程序。那么在程序完成安装后，还需要将隐私模式和虚拟显示器的配置，手动添加到 config.txt 中：\nhost_virtual_monitors = 1\rhost_privacy_mode = 1 最后需要注意，如果代理软件开启了规则模式，请确认已将 parsec.app 网址添加到规则列表中，否则系统将无法自动登录 Parsec 软件。\nParsec 隐私模式 支持显卡直通的虚拟机，虽说已经具备使用物理机显卡的能力了，但仍旧无法避免系统会自动选择使用虚拟显卡来渲染图形的尴尬情况。如果不对默认的虚拟显卡进行限制，那么即便使用 Parsec 远程连接到了虚拟机上，虚拟机也会默认使用虚拟显卡来输出桌面图像，从而导致各种延迟卡顿。\nEasy-GPU-PV 会直接在设备管理器中，将虚拟显卡的驱动设置为禁用。禁用虚拟显卡驱动之后，系统默认情况下就都会使用直通的 GPU 对图像进行渲染了。\n但随之而来的问题是，一旦虚拟显卡的驱动被禁用，虚拟机的显示分辨率就会被锁定在 1024x768 (4:3) 且无法调整，这是虚拟机本身的限制。这种情况下，远程连接到虚拟机时，即便使用了直通的 GPU 编解码，但显示分辨率也会被锁定在 1024x768 或之下，显示是不完美的。\n但所幸 Parsec 支持开启隐私模式，隐私模式下当远程连接发起时，远程主机会启用虚拟显示器，而虚拟显示器的内容会使用直通的 GPU 进行编解码。更重要的是，虚拟显示器的分辨率是不受限制的。\n注意，Parsec 中开启虚拟显示器和开启隐私模式是两个独立的选项，你必须同时启用它们，才能够让直通的 GPU 输出虚拟显示器的桌面图像。\nParsec 虚拟显示器 虚拟显示器（Virtual Display）是在硬件上模拟出来的额外显示器，它的作用类似于 Windows 10 系统上的任务视图，主要是为了提供额外的桌面空间。\n虽然虚拟显示器宣称可以最大限度地提高桌面空间的利用率及提高工作效率等，但实际上这种技术带来的效果并不理想。不过，虚拟显示器对于显卡直通的 Hyper-V 虚拟机上的 Parsec 来说，却尤为重要。\nParsec 中使用到虚拟显示器的是被称为隐私模式（Privacy Mode）功能。开启该模式后，当远程 Client 客户机连接 Host 主机时，主机上的屏幕将被设置为不可见，从而避免其他人窥视主机屏幕，从而保护了用户的隐私。该模式就是利用虚拟显示器，结合 Windows 系统的显示机制来实现的。\n当 Windows 系统连接两块显示器（无论是否为物理显示器）时，显示设置中会列出这些屏幕：\n多显示器设置中通常包含以下选项：\nParsec 在没有客户机连接时，不会启用虚拟显示器。\n当有客户机连接主机时，虚拟显示器会随之启动，系统将识别 Parsec 的虚拟显示器为 2 号显示器。系统识别虚拟显示器后，Parsec 会调整多显示器选项，将其设置为“仅在 2 上显示”，间接让 1 号“物理”显示器不再显示任何画面。\n这个做法是相当巧妙的，可以说 Parsec 的隐私模式和虚拟显示器功能，正好歪打正着地解决了 GPU 直通的虚拟机被远程连接时的显示分辨率问题。\n","permalink":"https://dylan127c.github.io/posts/hyper-v-easy-gpu-pv/","summary":"虚拟机 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。\n在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。\nVMware Workstation VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。\nVMware Workstation 可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT 开发人员和系统管理员而言， VMware 在虚拟网路，实时快照，拖曳共享文件夹，支持 PXE 等方面的特点使它成为必不可少的工具。\nHyper-V Hyper-V 是微软的一款虚拟化产品，是微软第一个采用类似 Vmware ESXi 和 Citrix Xen 的基于 hypervisor 的技术。这也意味着微软会更加直接地与市场先行者 VMware 展开竞争，但竞争的方式会有所不同。\nHyper-V 是微软提出的一种系统管理程序虚拟化技术，能够实现桌面虚拟化。Hyper-V 最初预定在 2008 年第一季度，与 Windows Server 2008 同时发布。Hyper-V Server 2012 完成 RTM 版发布。\n虚拟化技术 一般的个人计算机都支持虚拟化技术，使用该技术需要先在 BIOS 主板中开启特定功能：\n支持 Intel 芯片组的主板，需要在 BIOS 中启用 Intel Virtualization Technology (VT-x）选项； 支持 AMD 芯片组的主板，需要在 BIOS 中启用 SVM Mode 选项。 对于 VMware Workstation 来说，只要 BIOS 中启用了 VT-x 或 SVM Mode 后，无需额外的设置，安装后即可可使用。","title":"Hyper-V \u0026 Easy-GPU-PV"},{"content":"程序调试 DEBUG 是程序开发人员必备的调试程序技能。在企业中程序开发和程序调试的比例为 1:1.5 ，是必须要掌握的技能之一。其作用主要有三个：\n追踪代码的运行流畅； 程序运行异常定位； 线上问题追踪。 调试说明 在程序进行调试之前，需要为指定代码设置断点（F9 快捷键）。调试过程中只涉及了 8 个功能，其对应着 8 个 IDEA 上的调试按钮：\n表格中说明了各个按钮的具体作用：\n按钮 描述 Show Excution Point：快速定位到当前调试行上 Step Over：跳过当前调试行，即不步入当前行中的方法体内 Step Into：用于步入非官方类库的方法内，但不能进入官方类库的方法中 Force Step Into：强制步入任何方法内。查看底层源码时，可以用这个功能步入官方类库的方法内 Step Out：从当前步入的方法内退出到方法调用处 Drop Frame：回退断点。回退到对象创建或方法调用行 Run to Cursor：运行到光标处。你可以将光标定位到指定行，使用此功能让代码运行至光标指定行，免除设置断点操作 Evaluate Expression\u0026hellip;：表达式计算，不常使用 调试过程中可以查看变量的当前值，共有三种方式：\n在 IntelliJ IDEA Debug.控制台内的 Variables 窗口中查看； 将鼠标悬停到变量上，IDEA 会弹出相关的变量信息窗口； 程序区直接查看变量。 表达式计算 Evaluate Expression：表达式计算，默认快捷键 Alt + F8。\n使用计算表达式可以更改调试中变量的值：\n条件断点 在遇到诸如 for 循环时，你可能只需要查看某个中间条件的执行结果，这个时候可以使用条件断点。\n条件断点用于规定指定的条件，程序运行到符合条件时将暂停执行，此时可以从设定点开始调试或中断调试。\n多线程调试 启用多线程调试需要调整断点的挂起级别为Thread ，然后在 Frames 中选择线程进行调试即可。\n此时所在调试的线程是红色勾标记，而处于等待调试的线程则是红色圆点标记。\n选择 Thread-0 并运行调试至 happen 方法结束，则只有该线程会输出，其他的线程则仍会处于等待调试状态：\n如果当前线程完全结束，则会自动切换到另一个线程的调试中：\n","permalink":"https://dylan127c.github.io/posts/intellij-idea-debug/","summary":"程序调试 DEBUG 是程序开发人员必备的调试程序技能。在企业中程序开发和程序调试的比例为 1:1.5 ，是必须要掌握的技能之一。其作用主要有三个：\n追踪代码的运行流畅； 程序运行异常定位； 线上问题追踪。 调试说明 在程序进行调试之前，需要为指定代码设置断点（F9 快捷键）。调试过程中只涉及了 8 个功能，其对应着 8 个 IDEA 上的调试按钮：\n表格中说明了各个按钮的具体作用：\n按钮 描述 Show Excution Point：快速定位到当前调试行上 Step Over：跳过当前调试行，即不步入当前行中的方法体内 Step Into：用于步入非官方类库的方法内，但不能进入官方类库的方法中 Force Step Into：强制步入任何方法内。查看底层源码时，可以用这个功能步入官方类库的方法内 Step Out：从当前步入的方法内退出到方法调用处 Drop Frame：回退断点。回退到对象创建或方法调用行 Run to Cursor：运行到光标处。你可以将光标定位到指定行，使用此功能让代码运行至光标指定行，免除设置断点操作 Evaluate Expression\u0026hellip;：表达式计算，不常使用 调试过程中可以查看变量的当前值，共有三种方式：\n在 IntelliJ IDEA Debug.控制台内的 Variables 窗口中查看； 将鼠标悬停到变量上，IDEA 会弹出相关的变量信息窗口； 程序区直接查看变量。 表达式计算 Evaluate Expression：表达式计算，默认快捷键 Alt + F8。\n使用计算表达式可以更改调试中变量的值：\n条件断点 在遇到诸如 for 循环时，你可能只需要查看某个中间条件的执行结果，这个时候可以使用条件断点。\n条件断点用于规定指定的条件，程序运行到符合条件时将暂停执行，此时可以从设定点开始调试或中断调试。\n多线程调试 启用多线程调试需要调整断点的挂起级别为Thread ，然后在 Frames 中选择线程进行调试即可。\n此时所在调试的线程是红色勾标记，而处于等待调试的线程则是红色圆点标记。\n选择 Thread-0 并运行调试至 happen 方法结束，则只有该线程会输出，其他的线程则仍会处于等待调试状态：","title":"IntelliJ IDEA Debug"},{"content":"DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。\n网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。\nDNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。\n所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。\n但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。\nTTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。\nTCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：\n网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。\n在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。\n应用层的目的是向应用程序提供网络接口，直接向用户提供服务。相比于下层的网络协议，应用协议要常见得多，可能大家都听过 HTTP 、HTTPS 、SSH 等应用层协议。\nTCP/IP 模型中应用层位于传输层之上，传输层的端口号用于标识数据所对应的应用层协议。也就是说，有端口号的协议都是应用层协议。应用协议是终端设备之间的应用通信规则。应用之间交互的信息叫消息，应用协议定义这些消息的格式以及消息的控制或操作的规则。\n计算机一般都有 65536 个端口，其中 1024 以下的端口号是系统端口。如果你的操作系统是 Linux，使用端口可能需要开启对于端口的权限。\n一些常用的协议端口号如下：\nHTTP 端口号 80 HTTPS 端口号 443 SSH 端口号 22 DNS 端口号 53 关于 HTTP 协议，一般都非常熟悉了。那什么是 HTTPS 协议呢？实际上 HTTPS 可以理解为 HTTP+SSL/TLS，即通过 SSL 或 TLS 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n因为 HTTP 协议传输是明文传输，显然在现代网络中，明文传输是非常不安全的，而 HTTPS 的加密传输正好可以弥补这点不足。\nPS：现在中间人攻击已经可以伪造 TLS 证书了，即传输还是可能被监听、解密。然后目前最新的传输层网络协议是 QUIC 协议了，有兴趣可以了解一下。\n网站无法访问 关于这里无法访问的网站，指代的是 GitHub 这种技术向的、但国内访问较为困难的网站。网站无法访问时，如若不考虑网络连通性的问题，那么症结通常有以下几个。\nDNS 污染/欺骗 DNS 污染是指一些刻意制造或无意中制造出来的域名服务器分组，把域名指往不正确的 IP 地址。它是一种让一般用户由于得到虚假目标主机 IP 而不能与其通信的方法，是一种 DNS 缓存投毒攻击。\nDNS 污染发生在用户请求的第一步上，直接从协议上对用户的 DNS 请求进行干扰。简单来说，DNS 污染就是运营商对于你的 DNS 域名解析请求进行修改，以插入广告，或者让你无法访问某些网站，另外网速也会变慢。\nDNS 劫持 DNS 劫持通过篡改 DNS 服务器上的数据返回给用户一个错误的查询结果来实现的，国内很多的 ISP（Internet Service Provider，中国移动、中国电信、中国联通等等）会故意修改自己 DNS 服务器上的记录，把某些敏感网站的记录修改成错误的 IP 地址。\n通过劫持 DNS 服务器，可以取得域名解析记录的控制权，进而修改域名的解析结果。导致对该域名的访问由原 IP 地址转入到修改后的指定 IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。\nIP 黑名单/敏感词过滤 关于 IP 黑名单和敏感词过滤都属于 GFW 防火墙的功能，有兴趣可以了解一下。\n关于 no-resolve 选项 如果希望能够顺利访问 GitHub 网站，可以选择使用代理服务。代理软件通常会提供多种模式，其中不免会遇到规则模式。\n规则模式下，代理软件允许用户使用规则列表，来灵活控制域名或 IP 是否使用代理服务。其中存在一项 IP 规则，它可以用于匹配 IP 的访问请求，借助本地 DNS 服务时，它也能匹配域名请求。\n默认情况下 IP 规则不添加 no-resolve 选项，如果有未匹配域名遇到无 no-resolve 选项的 IP 规则，那么程序会使用本地 DNS 对域名进行解析，以获取对于的域名 IP 地址。如果为 IP 规则添加 no-resolve 选项，那么程序将不再使用本地 DNS 对未匹配域名进行解析。\n以 MATCH 规则选用的模式，可将规则列表区分为黑名单模式和白名单模式：\n黑名单模式：所有未匹配域名规则或 IP 规则的请求，最终都会选用直连模式（DIRECT）； 白名单模式：所有未匹配域名贵或 IP 规则的请求，都会选用代理模式（PROXY）。 一般的规则列表，其中包含的规则顺序为：1. 域名规则；2. IP 规则；3. MATCH 规则。\n显然，是否在 IP 规则中添加 no-resolve 选项，影响的只有那些未能匹配域名规则的域名请求。换言之，只有未能匹配域名规则的域名请求，才会考虑是否需要使用 IP 规则的解析能力。\n假设存在某个域名请求，它不匹配任何的域名规则，以黑、白名单模式区分，存在以下情况：\n模式/域名属地 本地 DNS 能否解析 首次 IP 匹配 是否添加 no-resolve 选项 黑名单/国外 不能 国外 IP 规则 是，无法完成域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。 黑名单/国内 能 国内 IP 规则 是，能够完成域名解析；否，能够加快域名解析。 白名单/国外 不能 国外 IP 规则 是，能够加快域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。 白名单/国内 能 国内 IP 规则 是，有封号或其它风险；否，能够完成域名解析。 其中，本地 DNS 能否解析一栏并非百分百概率解析，它仅指代本地 DNS 服务器能否够大概率解析出域名的真实 IP 地址，原因是域名解析需要考虑 DNS 污染或 DNS 服务器是否在线等情况。\n有两种情况不是很好理解，即黑名单或白名单下，访问国外网址且无 no-resolve 选项：\nDNS 欺骗/污染：这种情况是及其正常的，本地 DNS 服务器通常会返回一个错误的 IP 地址，导致无法访问； DNS 泄露：从概率的角度出发，本地 DNS 是有可能将国外域名正确地解析出来，且同时能够对其发起正常的访问请求，但这会 DNS 泄露。 根据以上表格，为避免不必要的风险，可以得出黑、白名单下理论最优的 no-resolve 选项使用方式：\n国外 IP 规则需添加 no-resolve 选项，国内 IP 规则不需要添加 no-resolve 选项。 但真实情况是 IP 规则为混合使用，域名会自上而下地顺序匹配 IP 规则，这很可能会导致一种情况：某些国外域名在不希望进行 DNS 解析时，优先匹配到了一条没有添加 no-resolve 选项的国内 IP 规则，从而导致 DNS 欺骗/污染或 DNS 泄露。\nIP 规则最优实现 实际最优的 no-resolve 选项使用方式为：\n选择黑名单模式，仅添加国外 IP 规则，且该规则需要添加 no-resolve 选项。 白名单模式下，没有最优的 no-resolve 选项使用方式。对于国内 IP 地址而言，如果必须保证大概率不存在封号或其它风险，那么国内 IP 规则就必需存在且不能添加 no-resolve 选项。换言之国外域名未匹配时，它被本地 DNS 解析几乎是必然发生的。\n如果不在乎 DNS 是否泄露，那么就尽可能将不带 no-resolve 选项国内的 IP 规则添加到规则中，但即便如此也无法保证不出现封号或其它风险。\n可以根据需求在黑名单模式的前提下，将带有 no-resolve 选项的国外 IP 规则置于 IP 规则之前，而将不带 no-resolve 选项的国内 IP 规则置于 IP 规则之后。\n因为黑名单模式下，仅添加国外 IP 规则相当于衔接 MATCH 规则，如果前者无匹配，那么 MATCH 规则中也会需要使用本地 DNS 解析域名。所以是否在国外 IP 规则之后、MATCH 规则之前，添加不带 no-resolve 选项的国内 IP 规则，在黑名单模式下是可选的。\n而以上可选方案，也是目前最适用于白名单模式的规则排布。\n通过灵活控制 MATCH 规则选用 DIRECT 模式还是 PROXY 模式，可以让黑、白名单模式实现切换：\n黑名单下，MATCH 规则使用 DIRECT 模式； 白名单下，MATCH 规则使用 PROXY 模式。 ","permalink":"https://dylan127c.github.io/posts/internet-related/","summary":"DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。\n网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。\nDNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。\n所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。\n但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。\nTTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。\nTCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：\n网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。\n在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。","title":"Internet Related"},{"content":"加密与认证 加密是使用特殊的方式将数据资料进行编码，使得非法用户即时取得该加密信息，也无法获取真正的资料内容。因此数据加密可以保护数据，防止监听攻击等。其重点在于数据的安全性。\n认证多指的是身份认证，它用来判断某个身份的真实性。身份通过认证后，系统才可以依照不同的身份，给予不同的权限。其目的在于鉴别用户的真实性。\n公钥与私钥 在现代密码体系中，加密和解密是采用不同的密钥分别进行的，也就是俗称的非对称密钥密码系统，它所采用的是非对称加密算法（RSA）。每个通信方均需要两个密钥，即公钥与私钥，这两把密钥可以互为加解密。\n公钥是公开的，不需要保密；而私钥是由个人持有的，必须妥善保管与保密。\n公钥与私钥的原则：\n一个公钥对应一个私钥； 密钥对中，让大家都知道的是公钥；不能公开的、只有自己知道的是私钥； 如果用其中一个密钥对数据进行加密处理，则必定只有对应的另一个密钥才能对数据进行解密处理； 如果用其中一个密钥可以对数据进行解密，则该数据必然是对应着另一个密钥所进行加密的。 非对称密钥密码的主要应用，就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的。\n基于公钥的加密过程 假如有两个用户 Alice 和 Bob，Alice 需要把一段明文，通过双钥加密技术发送给 Bob，Bob 有一对公钥和私钥，那么加密、解密的过程如下：\nBob 将他的公钥传送给 Alice； Alice 使用 Bob 的公钥加密她的消息，并传送给 Bob； Bob 使用他的私钥解密 Alice 的消息。 基于公钥的认证过程 认证的过程不同于加密，主要用于鉴别用户的真伪。只需要鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。\n假如仍然有两个用户 Alice 和 Bob，Alice 需要让 Bob 知道自己是 Alice，而不是假冒的。因此 Alice 需要使用自己的私钥对文件进行签名，并发送给 Bob，Bob使用 Alice 的公钥对文件进行解密，如果解密成功，则证明 Alice 的私钥是正确的，从而完成了对 Alice 的身份认证。认证过程如下：\nAlice 使用私钥对文件进行加密，从而对文件进行签名； Alice 将签名的文件传送给 Bob； Bob 使用 Alice 的公钥解密文件，从而验证签名。 SSH 秘钥对的生成 使用 SSH 可以生成一对公钥和私钥的，例如 Git 中自带的 ssh-keygen 就可以使用以下命令创建公钥和私钥：\nssh-keygen -o 该命令会在 ~/.ssh 目录下生成两个文件 id_dsa、id_dsa.pub，其中 id_dsa 为私钥文件，id_dsa.pub 为公钥文件。\n某些网络支持 SSH 连接，你就可以将公钥上传到指定服务器，将私钥保存在本地用于连接服务器以完成认证身份的操作了。\n例如 GitHub 或 Gitee 就支持 SSH 连接，只需要将公钥按指定的方式上传到网站的服务器中，用户就可以使用私钥对文件进行签名并传送到它们的服务器进行用户认证。同样地，GitHub 或 Gitee 服务器也可以使用你的公钥对数据进行加密传输到用户的设备上，用户可以使用私钥对加密数据进行解密。\n疑难梳理 关于公钥和私钥的使用，你会发现无论是公钥还是私钥实际上都能应用在加解密文档上。那是不是实际上公钥和私钥是没有区别的？答案是否定的。\n对于非对称加密，公钥和私钥的加解密过程是不一样的。因此类似一些支持 SSH 的服务器，它们仅仅支持公钥加解密。这意味着即使你可以将你的私钥上传到服务器上，服务器也不能够使用你的私钥对文件进行加解密，因为服务器使用私钥加解密时，必然会出现在流程上的加解密错误。\n同样的，从开发者角度出发，公钥和私钥的区分是十分有必要的。这意味着对于加解密流程来说，你的服务仅仅需要编写一套针对公钥加解密的代码即可。\n私钥对于非对称加密来说是十分重要且不可外泄的，私钥的持有对象可以说是有且仅有你自己，但公钥则可以给许多其他的人持有，这实际上很贴合私钥与公钥的命名逻辑。\n对于非对称加密来说，你不必要了解公私钥加解密的流程。只要是非对称加密且加解密使用的算法一致，那么加解密的过程必然是固定不变且不可能出错的。\n","permalink":"https://dylan127c.github.io/posts/ssh-public-private-key/","summary":"加密与认证 加密是使用特殊的方式将数据资料进行编码，使得非法用户即时取得该加密信息，也无法获取真正的资料内容。因此数据加密可以保护数据，防止监听攻击等。其重点在于数据的安全性。\n认证多指的是身份认证，它用来判断某个身份的真实性。身份通过认证后，系统才可以依照不同的身份，给予不同的权限。其目的在于鉴别用户的真实性。\n公钥与私钥 在现代密码体系中，加密和解密是采用不同的密钥分别进行的，也就是俗称的非对称密钥密码系统，它所采用的是非对称加密算法（RSA）。每个通信方均需要两个密钥，即公钥与私钥，这两把密钥可以互为加解密。\n公钥是公开的，不需要保密；而私钥是由个人持有的，必须妥善保管与保密。\n公钥与私钥的原则：\n一个公钥对应一个私钥； 密钥对中，让大家都知道的是公钥；不能公开的、只有自己知道的是私钥； 如果用其中一个密钥对数据进行加密处理，则必定只有对应的另一个密钥才能对数据进行解密处理； 如果用其中一个密钥可以对数据进行解密，则该数据必然是对应着另一个密钥所进行加密的。 非对称密钥密码的主要应用，就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的。\n基于公钥的加密过程 假如有两个用户 Alice 和 Bob，Alice 需要把一段明文，通过双钥加密技术发送给 Bob，Bob 有一对公钥和私钥，那么加密、解密的过程如下：\nBob 将他的公钥传送给 Alice； Alice 使用 Bob 的公钥加密她的消息，并传送给 Bob； Bob 使用他的私钥解密 Alice 的消息。 基于公钥的认证过程 认证的过程不同于加密，主要用于鉴别用户的真伪。只需要鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。\n假如仍然有两个用户 Alice 和 Bob，Alice 需要让 Bob 知道自己是 Alice，而不是假冒的。因此 Alice 需要使用自己的私钥对文件进行签名，并发送给 Bob，Bob使用 Alice 的公钥对文件进行解密，如果解密成功，则证明 Alice 的私钥是正确的，从而完成了对 Alice 的身份认证。认证过程如下：\nAlice 使用私钥对文件进行加密，从而对文件进行签名； Alice 将签名的文件传送给 Bob； Bob 使用 Alice 的公钥解密文件，从而验证签名。 SSH 秘钥对的生成 使用 SSH 可以生成一对公钥和私钥的，例如 Git 中自带的 ssh-keygen 就可以使用以下命令创建公钥和私钥：\nssh-keygen -o 该命令会在 ~/.","title":"SSH Public \u0026 Private Key"},{"content":"概述 Java 是一门面向对象的编程语言； Java 主要用于编写网络应用程序的后台逻辑，如网页的后台、Windows 应用程序或手机 App 等； Java 是一门高级的编程语言。所谓的高级语言，其底层都是由基础语言编写而成，Java 亦是如此； Java 的代码运行在 JVM 上，JVM 全称是 Java Virtual Machine。Java 的多平台的可移植性，正正是依赖于 JVM 可以在多平台上运行。 数据类型 学习任何一门计算机语言，最基本的步骤是了解该门语言中的数据类型。\nJava 中的数据类型分为两类：1. 基本数据类型；2. 引用数据类型。\n基本数据类型具体分类：\n类型 大小及范围 byte 1 字节，-128~127 short 2 字节，-32768~32767 int 4 字节，-2^31~2^31-1 long 8 字节，-2^63~2^63-1 float 4 字节，-3.40282347E+38F~3.40282347E+38F（有效位数 6~7 位） double 8 字节，-1.79769313486231570E+308~1.79769313486231570E+308（有效位数 15 位） char 2 字节，0~65535 boolean 1 字节，true/false 基本数据类型之间的转换关系：\nflowchart LR\rA(byte) --\u003e B(short) --\u003e C(int) --\u003e D(long) -.-\u003e F(double)\rC -.-\u003e G(float)\rC --\u003e F\rE(char) --\u003e C\rG --\u003e F\rstyle A fill:#FF9224\rstyle B fill:#FF9224\rstyle C fill:#FF9224\rstyle D fill:#FF9224\rstyle E fill:#97CBFF\r其中，实线表示可以安全地进行转换，虚线则表示转换会丢失部分精度。\n除去基本数据类型以外的所有其他类型，都属于引用数据类型。（数组是特殊的类，它也属于引用数据类型。）\n流程控制 任何语言都离不开流程控制语句，Java 的基本流程控制语句有三类：判断、选择、循环。\n判断 关键字：if、else、else if\npublic class Sample { public static void main(String[] args) { int num = 10; if (num \u0026lt; 0) { System.out.println(\u0026#34;It\u0026#39;s less than zero.\u0026#34;); } else if (num \u0026gt;= 0 \u0026amp;\u0026amp; num \u0026lt; 10) { System.out.println(\u0026#34;It\u0026#39;s more than zero meanwhile, less than ten.\u0026#34;); } else { System.out.println(\u0026#34;It\u0026#39;s equal to ten or more than it.\u0026#34;); } } } 选择 关键字：switch、case、break\npublic class Sample { public static void main(String[] args) { int num = 4; switch (num) { case 1: System.out.println(\u0026#34;It\u0026#39;s one.\u0026#34;); break; // do not forget case 2: System.out.println(\u0026#34;It\u0026#39;s two.\u0026#34;); break; case 3: System.out.println(\u0026#34;It\u0026#39;s three.\u0026#34;); break; default: System.out.println(\u0026#34;I don\u0026#39;t know.\u0026#34;); break; } } } 多重选择 switch 语句中，case 关键字能够接收的判断类型是有限的。它仅能接收以下几种类型：\n类型为 char、byte、short 或 int 的常量表达式； 枚举常量； 从 Java 7 开始，case 标签还可以是字符串字面量。 用一种更为简单的思维来理解 switch\u0026hellip;case 语句，即 case 内部实际是采用 == 来完成对象间的比较。\n假设 switch 能够接收引用数据类型参数，那么 case 就只会比较该对象之间的地址是否一致，这显然不符合 switch\u0026hellip;case 的设计逻辑，这也是为什么 case 关键字只能够接收有限的判断类型的原因。\n字符串字面量存在于静态常量池，有别于普通的字符串对象，字符串字面量可以直接使用 == 完成比较，因此它可以作为 case 的入参。\n循环 关键字：for\npublic class Sample { public static void main(String[] args) { for (int num = 3; num \u0026gt; 0; num--) { System.out.println(\u0026#34;Now is \u0026#34; + num); // 3、2、1 } } } 关键字：while、do\u0026hellip;while\npublic class Sample { public static void main(String[] args) { int num = 3; while (num-- \u0026gt; 0) { // 变量num会先进行比较再进行自减 System.out.println(\u0026#34;I am \u0026#34; + num); // 2、1、0 } do { System.out.println(\u0026#34;I am \u0026#34; + num); // -1、0、1、2、3 } while (num++ \u0026lt; 3); // 变量num会先进行比较再进行自增 System.out.println(\u0026#34;Finally, I am \u0026#34; + num); // 4 } } while 和 do\u0026hellip;while 类似：前者只有在满足条件的情况下，才会执行循环；后者则至少会执行一次循环，后续循环是否继续需要根据条件进行判断。\n流程控制中，一般还会使用到 break、continue 关键字，它们用于中断流程。\nClass 类 Java 中事无巨细都需要涉及到 Class 类，类可以说是构成 Java 程序的基本单位。\n简单的类通常都具备字段（变量） Field 和方法 Method 两种成员类型。除字段、方法外，类中还能编写诸如内部类、内部枚举类、内部抽象类、嵌入/内部接口和内部注解等其他成员类型。\npublic class Sample { static int classField; // 静态变量 int instanceField; // 成员变量 static void classMethod() { /*静态方法*/ } void instanceMethod() { /* 成员方法 */ } private void sample() { class MethodInnerClass { /* 方法内部类 */ } MethodInnerClass methodInnerClass = new MethodInnerClass(); } enum NormalEnum { /* 内部枚举类 */} interface NormalInterface { /* 嵌入/内部接口 */ } @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Any { /* 内部注解 */ } class NormalClass { /* 内部类 */ } abstract class AbstractClass { /* 内部抽象类 */ } } 稍微需要注意的是方法内部类：方法内部类的定义必须在其实例化代码之前，否则编译器将报错。\nAbstract Class 抽象类 Abstract Class 抽象类实际就是使用 abstract 关键字修饰的类型，它和普通类有以下区别：\n抽象类无法直接实例化。一个普通的类如果使用 abstract 关键字修饰，那么它就无法进行直接地实例化； 抽象类中可以定义抽象方法。但，抽象类中没有抽象方法也是被允许的！ 抽象类中可以定义所有普通类中能够定义的成员类型。 抽象类的实例化共有两种实例化方式：\n借助抽象类的子类。子类覆写抽象类中所有的抽象方法后，子类即可被实例化； 借助匿名内部类。实例化抽象类的同时覆写其中的所有抽象方法。 思考一下，什么情况下类必须使用 abstract 关键字修饰呢？答案是类具有抽象方法时。如果类中仅存在 abstract 修饰的成员类型，类上是不需要使用 abstract 关键字修饰的。\n以下情况是被允许的：\npublic class Some { abstract class Inside {/*...*/} } Interface 接口 Interface 接口在 Java 中是一个抽象类型，接口最初的定义是抽象方法的集合，以 interface 关键字声明。\n注意，接口并不是类。接口和类同属于 Java 数据类型中的引用数据类型，它们是同等级的。类是用 class 定义，而接口是用 interface 定义。\n接口中可定义的成员有：\n成员 说明 常量 默认隐式使用 public static final 修饰 抽象方法 默认隐式使用 public abstract 修饰 静态方法（Java 8 新增） 需显式使用 static 修饰，默认隐式使用 public 修饰 默认方法（Java 8 新增） 需显式使用 default 修饰，默认隐式使用 public 修饰 私有方法（Java 9 新增） 需显式使用 private 修饰 public interface Sample { int CONSTANT_NUM = 2; // 常量 void abstractMethod(); // 抽象方法 static void staticMethod() { /* 静态方法 */ } default void defaultMethod() { /* 默认方法 */ } private void privateMethod() { /* 私有方法 */ } } 实际上，接口中不仅仅只能定义以上的成员类型，诸如内部类、内部枚举类等其他的成员类型也能够定义在接口之中。\n但需要注意的是，在接口中定义的其他成员类型无法选择访问修饰符的类型。默认情况下接口统一隐式使用了 public static 对这些成员进行了修饰（其中，内部枚举类仅使用了 public 修饰）。\npublic interface Some { enum NormalEnum { /* 内部枚举类 */ } interface NormalInterface { /* 嵌入/内部接口 */ } @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Any { /* 内部注解 */ } class NormalClass { /* 内部类 */ } abstract class AbstractClass { /* 内部抽象类 */ } } 抽象类和接口的区别 接口不具有构造方法； 接口不具有静态代码块或代码块 Java 8 之前，接口中所有的方法必须是抽象方法（Java 8 新增了静态方法和默认方法，Java 9 新增了私有方法）； 接口中的变量只能是用 public static final 修饰的常量； 接口不能被继承（extends）了，但可以被实现（implements）； 类支持多实现，但仅支持单继承； 接口中只有私有方法是使用 private 修饰的，除此之外其他所有方法使用的访问修饰符都是 public； 接口中声明的内部元素均隐式使用 public 修饰；除内部枚举类外，其他内部元素同时隐式使用 static 修饰。 Enum 枚举 Enum 枚举类是一个特殊的类，一般表示一组常量，不常用。\n枚举类使用范例：\npublic class EnumTest { @Test public void test() { String currentSymbol = \u0026#34;EXTRA_LARGE\u0026#34;; Size size = Enum.valueOf(Size.class, currentSymbol); // 比较两个枚举类型的值时，不需要使用equals，注意Size.EXTRA_LARGE的类型是Size，而不是String Assert.assertSame(size, Size.EXTRA_LARGE); // 额外信息为String类型 Assert.assertEquals(\u0026#34;XL\u0026#34;, size.getExtraInfo()); // 枚举类中的成员方法name()可以取出对应枚举类实例化对象所代表的值的String表示形式 Assert.assertEquals(Size.EXTRA_LARGE.name(), SimpleSize.EXTRA_LARGE.name()); } } /** * 枚举类Size中包含四个常量，其中可以使用小括号去定义该常量的一个或多个额外信息，该额外信息以String类型进行存储， * 需要作为私有构造器显式参数（形参）传入。因此，如果具备额外信息，则必须提供有参构造。 * 此时定义Size类的私有字段extraInfo，将用于保存当前私有构造所传入的显式参数，即对应常量的额外信息。 */ enum Size { SMALL(\u0026#34;S\u0026#34;), MEDIUM(\u0026#34;M\u0026#34;), LARGE(\u0026#34;L\u0026#34;), EXTRA_LARGE(\u0026#34;XL\u0026#34;); private final String extraInfo; Size(String extraInfo) { this.extraInfo = extraInfo; } public String getExtraInfo() { return this.extraInfo; } } /** * 简单的枚举类。 */ enum SimpleSize { SMALL, MEDIUM, LARGE, EXTRA_LARGE; } 常用的获取枚举类实例化对象的方式有三种：\n枚举类中的枚举对象，相当于类中的常量，可以直接通过类名加枚举常量名称获取； 通过 Enum.valueOf 静态方法，可以获取指定枚举类中指定名称的枚举类对象； 通过指定枚举类的 valueOf 静态方法，可以获取指定名称的该枚举类对象。 public class EnumTest { @Test public void test() { SimpleSize simpleSizeA = Enum.valueOf(SimpleSize.class, \u0026#34;MEDIUM\u0026#34;); SimpleSize simpleSizeB = SimpleSize.valueOf(\u0026#34;EXTRA_LARGE\u0026#34;); Assert.assertSame(SimpleSize.MEDIUM, simpleSizeA); Assert.assertSame(SimpleSize.EXTRA_LARGE, simpleSizeB); int index = SimpleSize.SMALL.ordinal(); Assert.assertEquals(0, index); SimpleSize[] values = SimpleSize.values(); Assert.assertEquals(4, values.length); } } enum SimpleSize { SMALL, MEDIUM, LARGE, EXTRA_LARGE; } 枚举类对象在对应枚举类中的索引位置，可以通过成员方法 ordinal 获取；可以通过枚举类中的静态方法 values 获取到对应的枚举类型中的所有枚举对象的数组。\nAnnotation 注解 Annotation 注解又称 Java 标注，它是 JDK 5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注的。\nJava 允许通过反射获取标注内容。在编译器生成类文件时，标注会被嵌入到字节码中。\nJava 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，当然它也支持自定义 Java 标注。\n注解就像一个预设信息清单，程序如果需要自定义注解，那么必然会有对应的反射代码嵌入在程序内，用于获取程序上对应注解的对象。成功获取对应注解的对象后，即可通过注解中提供的方法，获取到相关的当前预设信息。\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Simple { String value() default \u0026#34;dylan\u0026#34;; } public class AnnotationTest { @Test public void test() { try { Method annotationMethod = AnnotationTest.class .getDeclaredMethod(\u0026#34;annotationMethod\u0026#34;); Simple simple = annotationMethod.getAnnotation(Simple.class); Assert.assertEquals(\u0026#34;rose\u0026#34;, simple.value()); } catch (NoSuchMethodException e) { e.printStackTrace(); } } @Simple(\u0026#34;rose\u0026#34;) public void annotationMethod() { } } 注解其实类似于接口，但不同的是注解中不支持定义静态方法、默认方法或私有方法，它仅支持定义常量和抽象方法。且注解中的抽象方法，允许使用 default 关键字为方法设置一个默认的返回值。\n既然与接口类似，注解是否可以采用匿名内部类的方式获取到注解对象？答案是肯定的。\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Simple { String value() default \u0026#34;dylan\u0026#34;; } public class AnnotationTest { @Test public void test() { Simple simple = new Simple() { @Override public String value() { return \u0026#34;dylan\u0026#34;; } @Override public Class\u0026lt;? extends Annotation\u0026gt; annotationType() { return Simple.class; } }; Assert.assertEquals(\u0026#34;dylan\u0026#34;, simple.value()); } } 采用匿名内部类实例化注解对象时，要求必须覆写 annotationType 抽象方法，该方法是哪里来的呢？\nJava 中的所有注解实际都实现了 Annotation 接口，该接口中有四个抽象方法：\npublic interface Annotation { boolean equals(Object obj); int hashCode(); String toString(); Class\u0026lt;? extends Annotation\u0026gt; annotationType(); } Simple 注解类型实现了 Annotation 接口：\n采用匿名内部类实例化注解对象时，对象遵循所有类型继承自 Object 类型，因此 equal、hashCode 和 toString 方法都能从 Object 类中继承而来，剩下一个 annotationType 抽象方法是必须要求覆写的。\n实际上，注解如果在方法上使用，那么当方法被加载时，Java 程序会默默完成该注解的匿名实例化过程：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Simple { String value() default \u0026#34;dylan\u0026#34;; } public class AnnotationTest { @Test @Simple public void test() { try { Method test = AnnotationTest.class.getMethod(\u0026#34;test\u0026#34;); // load method Simple simple = test.getAnnotation(Simple.class); Assert.assertEquals(\u0026#34;dylan\u0026#34;, simple.value()); Assert.assertEquals(\u0026#34;Simple\u0026#34;, simple.annotationType().getSimpleName()); } catch (NoSuchMethodException e) { e.printStackTrace(); } } } 访问修饰符 Access Modifier 访问修饰符用于界定 Java 中成员的被访问权限，这样的访问修饰符有四个：public、protected、(default) 和 private。\n假设所有的类均由 public 关键字修饰，则访问修饰符作用于类中成员时，其作用如下：\nAccess Modifier Usage public 所有同包、非同包的类均可访问 protected 仅限同包的类、非同包的子类可访问 (default) 仅限同包的类可访问 private 仅限当前类访问 类、接口等引用数据类型也需要使用访问修饰符，用于规定它们是否能够被其他类所访问，用于类或接口等数据类型的访问修饰符仅有两个：public 和 (default)。\npublic class Some { // 访问修饰符用于修饰成员变量 public int a = 1; protected int b = 2; int c = 3; private int d = 4; // 访问修饰符用于修饰成员方法 public void methodA() { System.out.println(\u0026#34;MethodA.\u0026#34;); } protected void methodB() { System.out.println(\u0026#34;MethodB.\u0026#34;); } void methodC() { System.out.println(\u0026#34;MethodC.\u0026#34;); } private void methodD() { System.out.println(\u0026#34;MethodD.\u0026#34;); } // 访问修饰符用于修饰内部类 public class InnerClassA { //.. } protected class InnerClassB { // .. } class InnerClassC { // .. } private class InnerClassD { // .. } } 那为什么类或接口不能够使用 protected 或 private 修饰？（虽然这是语法规定，但也可以思考一下。）\n首先需要明确一点，之所以在类或接口上使用访问修饰符，是为了规定类或接口是否能够被其他的类所访问。只有其他的类拥有目标类或接口的访问权时，才能进一步谈论继承或实现。\n那么也就是说，访问修饰符 protected 中相关的子类访问规则是没有用的。如果 protected 去除了相关的子类访问规则，它的作用即完全等同于访问修饰符 (default)。显然类或接口没有必要使用 protected 访问修饰符。\n其次，同样是因为使用访问修饰符是为了规范其他类访问目标类或接口的访问规则，如果类或接口上用 private 修饰（假如生效），那么目标类或接口则等同于不接受任何访问，这显然是无意义的。\n常用关键字 Java 常用的关键字有三个：static、final、abstract。\nstatic 关键字 static 的作用有三个：\nstatic 关键字可以用于静态代码块。静态代码块用于完成类加载时的相关初始化操作； static 关键字可以修饰字段和方法。被修饰的字段和方法属于类，这些字段和方法会在类加载的时一并被初始化； static 关键字可以修饰内部类、内部枚举类、内部抽象类、嵌入接口、内部注解等，被修饰的元素都属于类元素。 在访问权限允许的情况下，其他类可以通过类名加 static 关键字修饰的元素名称，完成对静态变量、静态方法或静态内部类的引用：\npublic class Some { public static int a = 1; static void methodSome() { System.out.println(\u0026#34;MethodSome.\u0026#34;); } static class InnerClass { private void methodSome() { // 与方法访问成员变量的规则一致，在不存在对应局部变量的情况下，会向上查找相关的成员变量 System.out.println(a); } } } // 同一文件下的其他非public修饰的类，算做同包下的其他类 class OutsideClass { Some.InnerClass innerClass = new Some.InnerClass(); public void methodSome() { System.out.println(innerClass); } } 内部接口 interface 是特殊的静态内部类，因为所有在类中的 interface 默认会被 static 关键字修饰：\npublic class Some { int num = 1; Else.InnerInterface innerInterface = () -\u0026gt; { // lambda表达允许修改非final修饰的基本数据类型的成员变量的值 // 局部变量在Java 8后默认使用final进行修饰，因此不可更改 num = 2; }; @Test public void test() { innerInterface.abstractMethod(); Assert.assertEquals(2, num); } } class Else { interface InnerInterface { void abstractMethod(); } } 关键字 static 引起的一个最经典的编译错误是：静态方法中使用了成员字段或成员方法。\n这个问题涉及到 JVM 类加载过程，但本篇不进行深究。你只需要知道，static 关键字修饰的字段或方法总是会随着类加载而被初始化，而类加载总是先于类的实例化。\n由于成员字段和成员方法只有在类实例化之后才能被使用，静态方法初始化时成员字段和成员方法还不存在，因此编译器发现了错误。\nfinal 关键字 final 的作用有三个：\n修饰字段：基本数据类型表示值不可变，引用数据类型表示地址不可变； 修饰方法：修饰成员方法则表示该方法不可被覆写； 修饰类：修饰类则该类不可被继承。 当修饰的变量是基本数据类型时，则表示该变量的值不可变；当修饰的变量是引用数据类型时，则表示该变量的地址不可变：\npublic class Some { private final int a = 1; private final int[] b = new int[]{1}; @Test public void test() { // a = 2; 无法通过编译器检查 b[0] = 2; Assert.assertEquals(1, a); Assert.assertEquals(2, b[0]); } } 关键字 final 用于修饰方法时，表示该方法不可被覆写（override）：\npublic class Some { final void method() { // .. } } class Else extends Some { // void method() {} 编译报错，无法override } 关键字 final 用于修饰类时，表示该类不可被继承（extends）。String 类就是典型的 final 类，该类不可被继承。覆写（override）的前提是继承，如果类无法被继承，自然类中的方法均无法被覆写。\nabstract 关键字 abstract 共有两个用法：\n用于声明一个方法是抽象方法，有且仅有抽象类或接口中可以拥有抽象方法； 用于声明一个类是抽象类，该类可以是内部类。 关键字 abstract 无法与关键字 static 一起使用！\n从类加载的角度看，类在完成实例化前，就必须先加载所有的静态成员。由于类加载无法人为进行干扰，如果此时某个静态方法是抽象方法，则将直接导致整个类加载过程失败。\n以下代码会在抽象类中编写抽象方法，并在同包的其他类中使用匿名内部类的方式实例化抽象类：\npublic class Some { @Test public void test() { // 使用匿名内部类的方式去实例化Some对象，注意仅有接口可以使用lambda表达式简化实例化过程 Else elseInstance =new Else() { @Override void specialMethod() { System.out.println(\u0026#34;..\u0026#34;); } }; } } abstract class Else { // 包含抽象方法的类一定是抽象类，但抽象类不一定包含抽象方法 abstract void specialMethod(); } 对于抽象类的实例化，要么就选择借助匿名内部类，在实例化的同时覆写抽象类中的抽象方法；要么是选择编写一个继承抽象类的实体类，去实例化该实体类（不作展示）。\n以下代码会在一个接口中编写一个抽象方法，并在同包的其他类中使用 lambda 表达式实例化该接口：\npublic class Some { @Test public void test() { Else elseInstance = () -\u0026gt; System.out.println(\u0026#34;..\u0026#34;); } } interface Else { // 接口中的抽象方法默认已使用public static abstract进行修饰，可省略代码的编写 void specialMethod(); } 假如在抽象类中的是抽象内部类，那么该如何实例化？\n以下代码会在一个抽象类中，编写一个抽象的内部类，并试图在另一个类中对该抽象内部类进行实例化操作：\npublic class Some { @Test public void test() { Else elseInstance = new Else() { }; // 非静态内部类的实例化，格式为：new Object().new ObjectInnerClass() Else.NormalInnerClass normalInnerClass = elseInstance.new NormalInnerClass(); Else.InnerClass innerClass = elseInstance.new InnerClass() { @Override void innerMethod() { System.out.println(\u0026#34;..\u0026#34;); } }; } } abstract class Else { // 关键字abstract可以不用，因为Else中没有抽象方法 class NormalInnerClass { } abstract class InnerClass { abstract void innerMethod(); } } 对于没有任何抽象方法的 Else 抽象类来说，匿名内部类实例化是不需要进行任何的覆写操作的（空覆写）；对于抽象类中具备抽象方法的内部抽象类来说，直接通过外部抽象类的对象来匿名实例化它即可。\n","permalink":"https://dylan127c.github.io/posts/first-page/","summary":"概述 Java 是一门面向对象的编程语言； Java 主要用于编写网络应用程序的后台逻辑，如网页的后台、Windows 应用程序或手机 App 等； Java 是一门高级的编程语言。所谓的高级语言，其底层都是由基础语言编写而成，Java 亦是如此； Java 的代码运行在 JVM 上，JVM 全称是 Java Virtual Machine。Java 的多平台的可移植性，正正是依赖于 JVM 可以在多平台上运行。 数据类型 学习任何一门计算机语言，最基本的步骤是了解该门语言中的数据类型。\nJava 中的数据类型分为两类：1. 基本数据类型；2. 引用数据类型。\n基本数据类型具体分类：\n类型 大小及范围 byte 1 字节，-128~127 short 2 字节，-32768~32767 int 4 字节，-2^31~2^31-1 long 8 字节，-2^63~2^63-1 float 4 字节，-3.40282347E+38F~3.40282347E+38F（有效位数 6~7 位） double 8 字节，-1.79769313486231570E+308~1.79769313486231570E+308（有效位数 15 位） char 2 字节，0~65535 boolean 1 字节，true/false 基本数据类型之间的转换关系：\nflowchart LR\rA(byte) --\u003e B(short) --\u003e C(int) --\u003e D(long) -.-\u003e F(double)\rC -.","title":"First Page"}]