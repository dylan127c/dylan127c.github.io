<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Internet Related | Think</title>
<meta name="keywords" content="DNS, TCP/IP, OSI">
<meta name="description" content="DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。
网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。
DNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。
所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。
但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。
TTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。
TCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：
网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。
在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。">
<meta name="author" content="dylan">
<link rel="canonical" href="https://dylan127c.github.io/posts/internet-related/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.eddf3fb605328bdcc3bebdfcc183268fffbd9d88fb4a11fc74a5362696c5a61c.css" integrity="sha256-7d8/tgUyi9zDvr38wYMmj/&#43;9nYj7ShH8dKU2JpbFphw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://dylan127c.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dylan127c.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dylan127c.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dylan127c.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://dylan127c.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/css/lightgallery.min.css">



<script src="/js/mermaid.min.js"></script>
<script>
    
    const config = {
        startOnLoad: true,
        theme: 'forest',
        themeVariables: {
            lineColor: "#ff8033" 
        },
        flowchart: {
            useMaxWidth: false,
            htmlLabels: true
        }
    };
    
    mermaid.initialize(config);
    
    
    window.onload = () => {
        window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
    }
</script><meta property="og:title" content="Internet Related" />
<meta property="og:description" content="DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。
网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。
DNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。
所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。
但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。
TTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。
TCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：
网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。
在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dylan127c.github.io/posts/internet-related/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-03-07T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Internet Related"/>
<meta name="twitter:description" content="DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。
网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。
DNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。
所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。
但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。
TTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。
TCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：
网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。
在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dylan127c.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Internet Related",
      "item": "https://dylan127c.github.io/posts/internet-related/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Internet Related",
  "name": "Internet Related",
  "description": "DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。\n网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。\nDNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。\n所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。\n但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。\nTTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。\nTCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：\n网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。\n在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。",
  "keywords": [
    "DNS", "TCP/IP", "OSI"
  ],
  "articleBody": "DNS 简述 从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 https://www.baidu.com 时，并无法直接根据站点名称访问到百度服务器。\n网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。\nDNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。\n所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。\n但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。\nTTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。\nTCP/IP 简述 常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：\n网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。\n在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。\n应用层的目的是向应用程序提供网络接口，直接向用户提供服务。相比于下层的网络协议，应用协议要常见得多，可能大家都听过 HTTP 、HTTPS 、SSH 等应用层协议。\nTCP/IP 模型中应用层位于传输层之上，传输层的端口号用于标识数据所对应的应用层协议。也就是说，有端口号的协议都是应用层协议。应用协议是终端设备之间的应用通信规则。应用之间交互的信息叫消息，应用协议定义这些消息的格式以及消息的控制或操作的规则。\n计算机一般都有 65536 个端口，其中 1024 以下的端口号是系统端口。如果你的操作系统是 Linux，使用端口可能需要开启对于端口的权限。\n一些常用的协议端口号如下：\nHTTP 端口号 80 HTTPS 端口号 443 SSH 端口号 22 DNS 端口号 53 关于 HTTP 协议，一般都非常熟悉了。那什么是 HTTPS 协议呢？实际上 HTTPS 可以理解为 HTTP+SSL/TLS，即通过 SSL 或 TLS 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n因为 HTTP 协议传输是明文传输，显然在现代网络中，明文传输是非常不安全的，而 HTTPS 的加密传输正好可以弥补这点不足。\nPS：现在中间人攻击已经可以伪造 TLS 证书了，即传输还是可能被监听、解密。然后目前最新的传输层网络协议是 QUIC 协议了，有兴趣可以了解一下。\n网站无法访问 关于这里无法访问的网站，指代的是 GitHub 这种技术向的、但国内访问较为困难的网站。网站无法访问时，如若不考虑网络连通性的问题，那么症结通常有以下几个。\nDNS 污染/欺骗 DNS 污染是指一些刻意制造或无意中制造出来的域名服务器分组，把域名指往不正确的 IP 地址。它是一种让一般用户由于得到虚假目标主机 IP 而不能与其通信的方法，是一种 DNS 缓存投毒攻击。\nDNS 污染发生在用户请求的第一步上，直接从协议上对用户的 DNS 请求进行干扰。简单来说，DNS 污染就是运营商对于你的 DNS 域名解析请求进行修改，以插入广告，或者让你无法访问某些网站，另外网速也会变慢。\nDNS 劫持 DNS 劫持通过篡改 DNS 服务器上的数据返回给用户一个错误的查询结果来实现的，国内很多的 ISP（Internet Service Provider，中国移动、中国电信、中国联通等等）会故意修改自己 DNS 服务器上的记录，把某些敏感网站的记录修改成错误的 IP 地址。\n通过劫持 DNS 服务器，可以取得域名解析记录的控制权，进而修改域名的解析结果。导致对该域名的访问由原 IP 地址转入到修改后的指定 IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。\nIP 黑名单/敏感词过滤 关于 IP 黑名单和敏感词过滤都属于 GFW 防火墙的功能，有兴趣可以了解一下。\n关于 no-resolve 选项 如果希望能够顺利访问 GitHub 网站，可以选择使用代理服务。代理软件通常会提供多种模式，其中不免会遇到规则模式。\n规则模式下，代理软件允许用户使用规则列表，来灵活控制域名或 IP 是否使用代理服务。其中存在一项 IP 规则，它可以用于匹配 IP 的访问请求，借助本地 DNS 服务时，它也能匹配域名请求。\n默认情况下 IP 规则不添加 no-resolve 选项，如果有未匹配域名遇到无 no-resolve 选项的 IP 规则，那么程序会使用本地 DNS 对域名进行解析，以获取对于的域名 IP 地址。如果为 IP 规则添加 no-resolve 选项，那么程序将不再使用本地 DNS 对未匹配域名进行解析。\n以 MATCH 规则选用的模式，可将规则列表区分为黑名单模式和白名单模式：\n黑名单模式：所有未匹配域名规则或 IP 规则的请求，最终都会选用直连模式（DIRECT）； 白名单模式：所有未匹配域名贵或 IP 规则的请求，都会选用代理模式（PROXY）。 一般的规则列表，其中包含的规则顺序为：1. 域名规则；2. IP 规则；3. MATCH 规则。\n显然，是否在 IP 规则中添加 no-resolve 选项，影响的只有那些未能匹配域名规则的域名请求。换言之，只有未能匹配域名规则的域名请求，才会考虑是否需要使用 IP 规则的解析能力。\n假设存在某个域名请求，它不匹配任何的域名规则，以黑、白名单模式区分，存在以下情况：\n模式/域名属地 本地 DNS 能否解析 首次 IP 匹配 是否添加 no-resolve 选项 黑名单/国外 不能 国外 IP 规则 是，无法完成域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。 黑名单/国内 能 国内 IP 规则 是，能够完成域名解析；否，能够加快域名解析。 白名单/国外 不能 国外 IP 规则 是，能够加快域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。 白名单/国内 能 国内 IP 规则 是，有封号或其它风险；否，能够完成域名解析。 其中，本地 DNS 能否解析一栏并非百分百概率解析，它仅指代本地 DNS 服务器能否够大概率解析出域名的真实 IP 地址，原因是域名解析需要考虑 DNS 污染或 DNS 服务器是否在线等情况。\n有两种情况不是很好理解，即黑名单或白名单下，访问国外网址且无 no-resolve 选项：\nDNS 欺骗/污染：这种情况是及其正常的，本地 DNS 服务器通常会返回一个错误的 IP 地址，导致无法访问； DNS 泄露：从概率的角度出发，本地 DNS 是有可能将国外域名正确地解析出来，且同时能够对其发起正常的访问请求，但这会 DNS 泄露。 根据以上表格，为避免不必要的风险，可以得出黑、白名单下理论最优的 no-resolve 选项使用方式：\n国外 IP 规则需添加 no-resolve 选项，国内 IP 规则不需要添加 no-resolve 选项。 但真实情况是 IP 规则为混合使用，域名会自上而下地顺序匹配 IP 规则，这很可能会导致一种情况：某些国外域名在不希望进行 DNS 解析时，优先匹配到了一条没有添加 no-resolve 选项的国内 IP 规则，从而导致 DNS 欺骗/污染或 DNS 泄露。\nIP 规则最优实现 实际最优的 no-resolve 选项使用方式为：\n选择黑名单模式，仅添加国外 IP 规则，且该规则需要添加 no-resolve 选项。 白名单模式下，没有最优的 no-resolve 选项使用方式。对于国内 IP 地址而言，如果必须保证大概率不存在封号或其它风险，那么国内 IP 规则就必需存在且不能添加 no-resolve 选项。换言之国外域名未匹配时，它被本地 DNS 解析几乎是必然发生的。\n如果不在乎 DNS 是否泄露，那么就尽可能将不带 no-resolve 选项国内的 IP 规则添加到规则中，但即便如此也无法保证不出现封号或其它风险。\n可以根据需求在黑名单模式的前提下，将带有 no-resolve 选项的国外 IP 规则置于 IP 规则之前，而将不带 no-resolve 选项的国内 IP 规则置于 IP 规则之后。\n因为黑名单模式下，仅添加国外 IP 规则相当于衔接 MATCH 规则，如果前者无匹配，那么 MATCH 规则中也会需要使用本地 DNS 解析域名。所以是否在国外 IP 规则之后、MATCH 规则之前，添加不带 no-resolve 选项的国内 IP 规则，在黑名单模式下是可选的。\n而以上可选方案，也是目前最适用于白名单模式的规则排布。\n通过灵活控制 MATCH 规则选用 DIRECT 模式还是 PROXY 模式，可以让黑、白名单模式实现切换：\n黑名单下，MATCH 规则使用 DIRECT 模式； 白名单下，MATCH 规则使用 PROXY 模式。 ",
  "wordCount" : "390",
  "inLanguage": "en",
  "datePublished": "2020-03-07T00:00:00Z",
  "dateModified": "2020-03-07T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "dylan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dylan127c.github.io/posts/internet-related/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Think",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dylan127c.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dylan127c.github.io/" accesskey="h" title="Think (Alt + H)">Think</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dylan127c.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://dylan127c.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://dylan127c.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://dylan127c.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dylan127c.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://dylan127c.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Internet Related
    </h1>
    <div class="post-meta"><span title='2020-03-07 00:00:00 +0000 UTC'>March 7, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dylan

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#dns-%e7%ae%80%e8%bf%b0" aria-label="DNS 简述">DNS 简述</a></li>
                <li>
                    <a href="#tcpip-%e7%ae%80%e8%bf%b0" aria-label="TCP/IP 简述">TCP/IP 简述</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%ab%99%e6%97%a0%e6%b3%95%e8%ae%bf%e9%97%ae" aria-label="网站无法访问">网站无法访问</a><ul>
                        
                <li>
                    <a href="#dns-%e6%b1%a1%e6%9f%93%e6%ac%ba%e9%aa%97" aria-label="DNS 污染/欺骗">DNS 污染/欺骗</a></li>
                <li>
                    <a href="#dns-%e5%8a%ab%e6%8c%81" aria-label="DNS 劫持">DNS 劫持</a></li>
                <li>
                    <a href="#ip-%e9%bb%91%e5%90%8d%e5%8d%95%e6%95%8f%e6%84%9f%e8%af%8d%e8%bf%87%e6%bb%a4" aria-label="IP 黑名单/敏感词过滤">IP 黑名单/敏感词过滤</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e-no-resolve-%e9%80%89%e9%a1%b9" aria-label="关于 no-resolve 选项">关于 no-resolve 选项</a></li>
                <li>
                    <a href="#ip-%e8%a7%84%e5%88%99%e6%9c%80%e4%bc%98%e5%ae%9e%e7%8e%b0" aria-label="IP 规则最优实现">IP 规则最优实现</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="dns-简述">DNS 简述<a hidden class="anchor" aria-hidden="true" href="#dns-简述">#</a></h3>
<p>从浏览器输入 URL 之后，会发生什么？实际上，当你访问百度网站的网址 <a href="https://www.baidu.com">https://www.baidu.com</a> 时，并无法直接根据站点名称访问到百度服务器。</p>
<p>网站地址又被称为 DOMAIN 域名，如果需要访问百度网站的服务器获取网页响应数据，则首先需要知道百度服务的确切 IP 地址。</p>
<p>DNS 全程为 DOMAIN NAME SYSTEM 域名解析系统，它实际上是网络拓扑中众多服务器中的其中一台。但有别于其他服务端机器，DNS 服务器主要提供的服务是将 DOMAIN 域名解析成确切的服务器 IP 地址。</p>
<p>所谓解析大多数情况下是通过映射表完成的，因为 DNS 服务器只是简单地存储了许多 DOMAIN 与 IP 之间的映射表。一般家庭网络会优先使用网络服务提供商的 DNS 服务器，来解析你所访问的目标网站的真实 IP。</p>
<p>但目标 DNS 服务器上也可能不存在指定域名为 KEY 的 VAL，即找不到对应的 IP 地址，一般造成这种情况多数是由于DNS 服务器中的解析记录过期导致的，其中涉及到 Time-To-Live 的概念。</p>
<p>TTL 指解析记录在 DNS 服务器中的缓存时间，如果记录过期了，那么 DNS 服务器中自然不存在对应的映射条目了。此时，目标 DNS 会会继续向上游的 DNS 服务器发起 DNS 解析请求，直到获取到真实 IP。</p>
<h3 id="tcpip-简述">TCP/IP 简述<a hidden class="anchor" aria-hidden="true" href="#tcpip-简述">#</a></h3>
<p>常用的网络模型一般有两个：TCP/IP 模型和 OSI 参考模型。下图是它们的模型结构及相应层中存在的协议类型：</p>
<p><img loading="lazy" src="../images/Internet%20Related.images/tcp_ip.jpg#center" alt="OSI模型、TCP/IP协议栈"  />
</p>
<p>网络模型最上层是应用层，是平时用户最常接触到的一层，HTTP 协议就位于该层；最下层的物理层，是最接近硬件的一层，那里有常常听说的以太网协议。</p>
<p>在 TCP/IP 模型中，应用层提供的服务相当于 OSI 模型的应用层、表示层和会话层的服务总和。不仅包含了管理通信连接的会话层功能、数据格式转换的表示层功能，还包括主机间交互的应用层功能。</p>
<p>应用层的目的是向应用程序提供网络接口，直接向用户提供服务。相比于下层的网络协议，应用协议要常见得多，可能大家都听过 HTTP 、HTTPS 、SSH 等应用层协议。</p>
<p>TCP/IP 模型中应用层位于传输层之上，传输层的端口号用于标识数据所对应的应用层协议。也就是说，有端口号的协议都是应用层协议。应用协议是终端设备之间的应用通信规则。应用之间交互的信息叫消息，应用协议定义这些消息的格式以及消息的控制或操作的规则。</p>
<p>计算机一般都有 65536 个端口，其中 1024 以下的端口号是系统端口。如果你的操作系统是 Linux，使用端口可能需要开启对于端口的权限。</p>
<p>一些常用的协议端口号如下：</p>
<ul>
<li>HTTP 端口号 80</li>
<li>HTTPS 端口号 443</li>
<li>SSH 端口号 22</li>
<li>DNS 端口号 53</li>
</ul>
<p>关于 HTTP 协议，一般都非常熟悉了。那什么是 HTTPS 协议呢？实际上 HTTPS 可以理解为 HTTP+SSL/TLS，即通过 SSL 或 TLS 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p>
<p>因为 HTTP 协议传输是明文传输，显然在现代网络中，明文传输是非常不安全的，而 HTTPS 的加密传输正好可以弥补这点不足。</p>
<p>PS：现在中间人攻击已经可以伪造 TLS 证书了，即传输还是可能被监听、解密。然后目前最新的传输层网络协议是 QUIC 协议了，有兴趣可以了解一下。</p>
<h3 id="网站无法访问">网站无法访问<a hidden class="anchor" aria-hidden="true" href="#网站无法访问">#</a></h3>
<p>关于这里无法访问的网站，指代的是 GitHub 这种技术向的、但国内访问较为困难的网站。网站无法访问时，如若不考虑网络连通性的问题，那么症结通常有以下几个。</p>
<h4 id="dns-污染欺骗">DNS 污染/欺骗<a hidden class="anchor" aria-hidden="true" href="#dns-污染欺骗">#</a></h4>
<p>DNS 污染是指一些刻意制造或无意中制造出来的域名服务器分组，把域名指往不正确的 IP 地址。它是一种让一般用户由于得到虚假目标主机 IP 而不能与其通信的方法，是一种 DNS 缓存投毒攻击。</p>
<p>DNS 污染发生在用户请求的第一步上，直接从协议上对用户的 DNS 请求进行干扰。简单来说，DNS 污染就是运营商对于你的 DNS 域名解析请求进行修改，以插入广告，或者让你无法访问某些网站，另外网速也会变慢。</p>
<h4 id="dns-劫持">DNS 劫持<a hidden class="anchor" aria-hidden="true" href="#dns-劫持">#</a></h4>
<p>DNS 劫持通过篡改 DNS 服务器上的数据返回给用户一个错误的查询结果来实现的，国内很多的 ISP（Internet Service Provider，中国移动、中国电信、中国联通等等）会故意修改自己 DNS 服务器上的记录，把某些敏感网站的记录修改成错误的 IP 地址。</p>
<p>通过劫持 DNS 服务器，可以取得域名解析记录的控制权，进而修改域名的解析结果。导致对该域名的访问由原 IP 地址转入到修改后的指定 IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。</p>
<h4 id="ip-黑名单敏感词过滤">IP 黑名单/敏感词过滤<a hidden class="anchor" aria-hidden="true" href="#ip-黑名单敏感词过滤">#</a></h4>
<p>关于 IP 黑名单和敏感词过滤都属于 GFW 防火墙的功能，有兴趣可以了解一下。</p>
<h3 id="关于-no-resolve-选项">关于 no-resolve 选项<a hidden class="anchor" aria-hidden="true" href="#关于-no-resolve-选项">#</a></h3>
<p>如果希望能够顺利访问 GitHub 网站，可以选择使用代理服务。代理软件通常会提供多种模式，其中不免会遇到规则模式。</p>
<p>规则模式下，代理软件允许用户使用规则列表，来灵活控制域名或 IP 是否使用代理服务。其中存在一项 IP 规则，它可以用于匹配 IP 的访问请求，借助本地 DNS 服务时，它也能匹配域名请求。</p>
<p>默认情况下 IP 规则不添加 no-resolve 选项，如果有未匹配域名遇到无 no-resolve 选项的 IP 规则，那么程序会使用本地 DNS 对域名进行解析，以获取对于的域名 IP 地址。如果为 IP 规则添加 no-resolve 选项，那么程序将不再使用本地 DNS 对未匹配域名进行解析。</p>
<p>以 MATCH 规则选用的模式，可将规则列表区分为黑名单模式和白名单模式：</p>
<ul>
<li>黑名单模式：所有未匹配域名规则或 IP 规则的请求，最终都会选用直连模式（DIRECT）；</li>
<li>白名单模式：所有未匹配域名贵或 IP 规则的请求，都会选用代理模式（PROXY）。</li>
</ul>
<p>一般的规则列表，其中包含的规则顺序为：1. 域名规则；2. IP 规则；3. MATCH 规则。</p>
<p>显然，是否在 IP 规则中添加 no-resolve 选项，影响的只有那些未能匹配域名规则的域名请求。换言之，只有未能匹配域名规则的域名请求，才会考虑是否需要使用 IP 规则的解析能力。</p>
<p>假设存在某个域名请求，它不匹配任何的域名规则，以黑、白名单模式区分，存在以下情况：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式/域名属地</th>
<th style="text-align:center">本地 DNS 能否解析</th>
<th style="text-align:center">首次 IP 匹配</th>
<th style="text-align:center">是否添加 no-resolve 选项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">黑名单/国外</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">国外 IP 规则</td>
<td style="text-align:center">是，无法完成域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。</td>
</tr>
<tr>
<td style="text-align:center">黑名单/国内</td>
<td style="text-align:center">能</td>
<td style="text-align:center">国内 IP 规则</td>
<td style="text-align:center">是，能够完成域名解析；否，能够加快域名解析。</td>
</tr>
<tr>
<td style="text-align:center">白名单/国外</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">国外 IP 规则</td>
<td style="text-align:center">是，能够加快域名解析；否，存在 DNS 欺骗/污染或 DNS 泄露风险。</td>
</tr>
<tr>
<td style="text-align:center">白名单/国内</td>
<td style="text-align:center">能</td>
<td style="text-align:center">国内 IP 规则</td>
<td style="text-align:center">是，有封号或其它风险；否，能够完成域名解析。</td>
</tr>
</tbody>
</table>
<p>其中，<strong>本地 DNS 能否解析</strong>一栏并非百分百概率解析，它仅指代本地 DNS 服务器能否够大概率解析出域名的真实 IP 地址，原因是域名解析需要考虑 DNS 污染或 DNS 服务器是否在线等情况。</p>
<p>有两种情况不是很好理解，即黑名单或白名单下，访问国外网址且无 no-resolve 选项：</p>
<ul>
<li>DNS 欺骗/污染：这种情况是及其正常的，本地 DNS 服务器通常会返回一个错误的 IP 地址，导致无法访问；</li>
<li>DNS 泄露：从概率的角度出发，本地 DNS 是有可能将国外域名正确地解析出来，且同时能够对其发起正常的访问请求，但这会 DNS 泄露。</li>
</ul>
<p>根据以上表格，为避免不必要的风险，可以得出黑、白名单下理论最优的 no-resolve 选项使用方式：</p>
<ul>
<li>国外 IP 规则需添加 no-resolve 选项，国内 IP 规则不需要添加 no-resolve 选项。</li>
</ul>
<p>但真实情况是 IP 规则为混合使用，域名会自上而下地顺序匹配 IP 规则，这很可能会导致一种情况：<strong>某些国外域名在不希望进行 DNS 解析时，优先匹配到了一条没有添加 no-resolve 选项的国内 IP 规则，从而导致 DNS 欺骗/污染或 DNS 泄露。</strong></p>
<h3 id="ip-规则最优实现">IP 规则最优实现<a hidden class="anchor" aria-hidden="true" href="#ip-规则最优实现">#</a></h3>
<p>实际最优的 no-resolve 选项使用方式为：</p>
<ul>
<li>选择黑名单模式，仅添加国外 IP 规则，且该规则需要添加 no-resolve 选项。</li>
</ul>
<p>白名单模式下，没有最优的 no-resolve 选项使用方式。对于国内 IP 地址而言，如果必须保证大概率不存在封号或其它风险，那么国内 IP 规则就必需存在且不能添加 no-resolve 选项。换言之国外域名未匹配时，它被本地 DNS 解析几乎是必然发生的。</p>
<p>如果不在乎 DNS 是否泄露，那么就尽可能将不带 no-resolve 选项国内的 IP 规则添加到规则中，但即便如此也无法保证不出现封号或其它风险。</p>
<p>可以根据需求在黑名单模式的前提下，将带有 no-resolve 选项的国外 IP 规则置于 IP 规则之前，而将不带 no-resolve 选项的国内 IP 规则置于 IP 规则之后。</p>
<p>因为黑名单模式下，仅添加国外 IP 规则相当于衔接 MATCH 规则，如果前者无匹配，那么 MATCH 规则中也会需要使用本地 DNS 解析域名。所以是否在国外 IP 规则之后、MATCH 规则之前，添加不带 no-resolve 选项的国内 IP 规则，在黑名单模式下是可选的。</p>
<p>而以上可选方案，也是目前最适用于白名单模式的规则排布。</p>
<p>通过灵活控制 MATCH 规则选用 DIRECT 模式还是 PROXY 模式，可以让黑、白名单模式实现切换：</p>
<ul>
<li>黑名单下，MATCH 规则使用 DIRECT 模式；</li>
<li>白名单下，MATCH 规则使用 PROXY 模式。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dylan127c.github.io/tags/dns/">DNS</a></li>
      <li><a href="https://dylan127c.github.io/tags/tcp/ip/">TCP/IP</a></li>
      <li><a href="https://dylan127c.github.io/tags/osi/">OSI</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dylan127c.github.io/posts/intellij-idea-debug/">
    <span class="title">« Prev</span>
    <br>
    <span>IntelliJ IDEA Debug</span>
  </a>
  <a class="next" href="https://dylan127c.github.io/posts/ssh-public-private-key/">
    <span class="title">Next »</span>
    <br>
    <span>SSH Public &amp; Private Key</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://dylan127c.github.io/">Think</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script type="text/javascript" src="/js/lightgallery.min.js"></script>
<script type="text/javascript" src="/js/lg-zoom.min.js"></script>
<script type="text/javascript" src="/js/lg-thumbnail.min.js"></script>

<script>

    
    var imgElements = document.querySelectorAll(".post-content p>img");
    if (imgElements.length > 0) {
        for (var i = 0; i < imgElements.length; i++) {
            var pElement = imgElements[i].parentNode;
            var aElement = document.createElement("a");

            aElement.setAttribute("href", "javascript:void(0)");
            aElement.setAttribute("name", "thumbnail" + i);

            
            aElement.setAttribute("onclick", "activate(this.name)")

            aElement.innerHTML = pElement.innerHTML;
            pElement.parentNode.replaceChild(aElement, pElement);
        }
        
        function activate(id) {
            document.getElementById(id).click();
        }

        
        

        
        var divThumbnail = document.createElement("div");
        divThumbnail.setAttribute("id", "lightgallery");

        
        divThumbnail.style.display = "none";

        
        for (var i = 0; i < imgElements.length; i++) {
            var aElement = document.createElement("a");
            aElement.setAttribute("href", imgElements[i].getAttribute("src"));
            aElement.setAttribute("id", "thumbnail" + i);
            aElement.innerHTML = imgElements[i].outerHTML;
            divThumbnail.appendChild(aElement);
        }
        
        var bodyElement = document.getElementsByTagName("body")[0];
        bodyElement.append(divThumbnail);

        
        lightGallery(divThumbnail, {
            thumbnail: false,
            speed: 500,
            counter: false
        });
    }

    
    var aLinkElement = document.querySelectorAll(".post-content p a")
    for (var i = 0; i < aLinkElement.length; i++) {
        aLinkElement[i].setAttribute("target", "_blank");
    }
    
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
